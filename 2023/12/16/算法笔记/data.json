{"title":"算法笔记","date":"2023-12-16T13:22:15.000Z","toc":null,"summary":"一些常用的算法笔记","source":"_posts/算法笔记.md","raw":"---\ntitle: 算法笔记\ndate: 2023-12-16 21:22:15\ntags: 算法\ntoc:\nsummary: 一些常用的算法笔记\ncopyright:\nauthor:\n---\n\n## C++头文件\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <unordered_map>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII\n\nvector<int> alls;\n```\n\n\n\n## string 的函数\n\n```c++\nint main(){\n    string a;\n    a.substr(0, k) //从 a[0] 开始到 a[k] ，返回这段字符串\n    a.substr(1)  //从 a[1] 开始到末尾，返回这段字符串\n}\n```\n\n\n\n## 排列组合\n\n![image-20221215192125061](../image/算法笔记/image-20221215192125061.png)![image-20221215192152255](../image/算法笔记/image-20221215192152255.png)\n\n```c++\n//从m个数里抽出n个数，进行全排列\nint arrange(int m,int n){\n    if(m==n)return n;\n    return m*arrange(m-1,n);\n}\n\n//从m个数里抽出n个数，进行组合排序\n//法一\nint cnm(int n,int m){\n    if(n==1)return m;\n    return m*cnm(n-1,m-1)/n;\n}\n//法二\nint cnm(int n,int m){\n    if(n==1)return m;\n    if(n==m)return 1;\n    return (cnm(n,m-1)+cnm(n-1,m-1));\n}\n\n//法三  从 i 个数里抽出 j 个数的方案数\nvoid init(){\n    for (int i = 0; i < N; i ++ )\n        for (int j = 0; j <= i; j ++ ){\n            if (!j) f[i][j] = 1;\n            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n        }\n}\n```\n\n## 二位前缀和\n\n![image-20230314194756707](../image/算法笔记/image-20230314194756707.png)\n\n## 差分\n\n在数组a[l,r]区间内加上c，则可表示为a[l]+=c,a[r+1]+=-c\n\n## 位运算\n\nx>>1，代表x右移一位，值变成1/2；x<<1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。\n\nx >> k & 1 , 代表 x 的第 k 位是否为 1.\n\n```c\nint lowbit(int x){\t\t\t//返回最后一个1的位数\n    return x&-x;\t\t\t/*例如 10 的二进制为 1010，则返回 10*/\n}\n```\n\n## 离散化\n\n```c++\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> alls;//储存所有待离散化的值\nsort(alls.begin(),alls.end());//将所有的值排序\nalls.erase(unique(alls.begin(),alls,end),alls.end);//去掉重复元素\n\n//二分法求出x对应的离散化的值\nint find(int x){\n    int l = 0, r = alls.size() - 1;\n    while(l < r){\n        int mid = l + r;\n        if(alls[mid] >= x){\n            r = mid;\n        }\n        else{\n            l = mid +1;\n        }\n    }\n    return r + 1;//返回 1，2，3，4……\n}\n```\n\n## KMP\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; //N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; //next[]数组，避免和头文件next冲突\nchar s[N], p[M];  //s为模式串， p为匹配串\n\nint main()\n{\n    cin >> n >> s+1 >> m >> p+1;  //下标从1开始\n\n    //求next[]数组\n    for(int i = 2, j = 0; i <= m; i++)\n    {\n        while(j && p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    }\n    //匹配操作\n    for(int i = 1, j = 0; i <= n; i++)\n    {\n        while(j && s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  //满足匹配条件，打印开头下标, 从0开始\n        {\n            //匹配完成后的具体操作\n            //如：输出以0开始的匹配子串的首字母下标\n            //printf(\"%d \", i - m); (若从1开始，加1)\n            j = ne[j];            //再次继续匹配\n        }\n    }\n\n    return 0;\n}\n```\n\n\n\n## Trie树\n\n![image-20230317125934107](../image/算法笔记/image-20230317125934107.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(char str[]) {\n\tint p = 0;\n\tfor (int i = 0; str[i]; i++) {\n\t\tint u = str[i] - 'a';\n\t\tif (son[p][u] == 0)\n\t\t\tson[p][u] = ++idx;\n\t\tp = son[p][u];\n\t}\n\tcnt[p]++;\n}\n\nint query(char str[]) {\n\tint p = 0;\n\tfor (int i = 0; str[i]; i++) {\n\t\tint u = str[i] - 'a';\n\t\tif (son[p][u] == 0)\n\t\t\treturn 0;\n\t\tp = son[p][u];\n\t}\n\treturn cnt[p];\n}\n```\n\n## 并查集\n\n```c++\nint find(int x)//返回x的祖宗节点，并压缩路径\n{\n\tif(p[x] != x)p[x] = find(p[x]);\n\treturn p[x];\n}\n\n// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]\n\n//如果要合并两个节点，则\nvoid merge(int a,int b){\n    //if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步\n    size[find(b)] += size[find(a)];  //必须先加size，再合并（a,b）\n    p[find(a)] = find(b);\n    //加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义\n    //如果先合并再相加，则代表两个相同的集合数量相加\n}\n```\n\n## 哈希表\n\n```c++\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了\nconst int N = 2e5 + 3;\t\t\t\t//大于数据范围的第一个质数\nconst int null = 0x3f3f3f3f;\t\t//规定空指针为 null 0x3f3f3f3f\n\nint h[N];\n\nint find(int x) {\n\tint t = (x % N + N) % N;\n\twhile (h[t] != null && h[t] != x) {\n\t\tt++;\n\t\tif (t == N) {\n\t\t\tt = 0;\n\t\t}\n\t}\n\treturn t;\t//如果这个位置是空的, 则返回的是他应该存储的位置\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tmemset(h, null, sizeof(h));\n\n\twhile (n --) {\n\t\tchar op[2];\n\t\tint x;\n\t\tscanf(\"%s%d\", op, &x);\n\t\tif (op[0] == 'I') {\n\t\t\th[find(x)] = x;\n\t\t} else {\n\t\t\tif (h[find(x)] == null) {\n\t\t\t\tprintf(\"No\");\n\t\t\t} else {\n\t\t\t\tprintf(\"Yes\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 字符串哈希表\n\n![image-20230318194927056](../image/算法笔记/image-20230318194927056.png)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nint const N = 10000010, P = 131; //P = 131 或者是 13331 Q一般取 2^64\n// P 代表进制 \n\nULL h[N], p[N];\nchar a[N];\n\nULL query(int l, int r) {\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tscanf(\"%s\", a + 1);\n\n\th[0] = 0, p[0] = 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\th[i] = h[i - 1] * P + a[i];\n\t\tp[i] = p[i - 1] * P;\n\t}\n\n\twhile (m --) {\n\t\tint l1, l2, r1, r2;\n\t\tscanf(\"%d %d %d %d\", &l1, &r1, &l2, &r2);\n\t\tif (query(l1, r1) == query(l2, r2))\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}\n```\n\n![image-20230323161436730](../image/算法笔记/image-20230323161436730.png)\n\n## 最小根堆\n\n```c++\n#include <iostream>\n#include <queue>\n#icnlude <vector>\n\npriority_queue<int, vector<int>, greater<int>> heap;\nheap.push(x), x = heap.top(), heap.pop();\n//每次弹出来的顶端都是最小值，并且push后堆会自动排序\n```\n\n## 关于sort()函数\n\n```c\nint num[100];\nbool cmp(int a,int b){\n    return a > b;\t\t\t\t\t\t\t\t //a>b为由大到小，b<a为由小到大\n}\nsort(num,num+100,cmp);\n\n```\n\n```c++\nstruct Edge{\n    int a, b , w;\n}edges[N];\n\nbool cmp(Edge a, Edge b){\t\t\t\t\t\t//按照w的大小排序，此时为递增\n    return a.w < b.w;\n}\n\nsort(edges, edges + m, cmp);\n```\n\n```c++\n//可以自定义排序\nbool cmp(int x,int y){\t\t\t\t\t//按照个位数的大小排序，此时为递增\n\treturn x % 10 < y % 10;\n}\n```\n\n\n\n1. sort(首地址，尾地址+1，cmp)\n2. 这个函数可以传两个或者三个参数\n3. 第一个参数是要排序的区间首地址\n4. 第二个参数是区间尾地址的下一个地址\n5. 第三个参数不写,则为递增排序\n\n## 求最大公约数、最小公倍数\n\n```c++\nint gcd(int a, int b){\t//最大公约数\n    return b ? gcd(b, a % b) : a;\n}\n\nint gcb(int a, int b){\t//最小公倍数\n    return a * b / gcd(a, b);\n}\n```\n\n## 取模\n\n同余定理：x%mod=(x+mod)%mod\n\n## 无穷大\n\ninf = 0x3f3f3f3f\n\n## 二分\n\n![image-20230406223240363](../image/算法笔记/image-20230406223240363.png)\n\n![image-20230406223251946](../image/算法笔记/image-20230406223251946.png)\n\n## 归并排序\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint a[N], tmp[N];\n\nvoid merge_sort(int l, int r){\n\tif(l >= r) return ;\n\t\n\tint mid = l + r >> 1;\n\tmerge_sort(l, mid), merge_sort(mid + 1, r);\n\t\n\tint k = 0, i = l, j = mid + 1;\n\twhile(i <= mid && j <= r){\n\t\tif(a[i] <= a[j]) tmp[k ++] = a[i ++];\n\t\telse tmp[k ++] = a[j ++];\n\t}\n\t\n\twhile(i <= mid) tmp[k ++] = a[i ++];\n\twhile(j <= r) tmp[k ++] = a[j ++];\n\t\n\tfor (int i = l, j = 0; i <= r; i ++, j ++) a[i] = tmp[j];\n}\n```\n\n## 图论\n\n初始化\n\n```c++\nint e[N], ne[N], h[N], w[N], dist[N], idx;\nint n, m;\nbool st[N];\n\nvoid add(int a, int b, int c) {\n\te[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n\tmemset(h, -1, sizeof h);\n}\n```\n\n\n\n### Dijkstra算法\n\n朴素版\n\n题型：稠密图\n\n思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边\n\n```c++\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        int t = -1;\n        for(int j = 1; j <= n; j++)\n        {\n            if(!visited[j] && (t == -1 || dist[j] < dist[t]))\n                t = j;\n        }\n        visited[t] = true;\n        for(int j = 1; j <= n; j++)\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n    }\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n```\n\n堆优化\n\n题型：稀疏图\n\n思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边\n\n```c++\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> heap; // 定义一个小根堆\n    // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，\n    // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。\n    heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，\n                         // 这里显然要根据距离排序\n    while(heap.size())\n    {\n        PII k = heap.top(); // 取不在集合S中距离最短的点\n        heap.pop();\n        int ver = k.second, distance = k.first;\n\n        if(st[ver]) continue;\n        st[ver] = true;\n\n        for(int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。\n            if(dist[j] > distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({ dist[j], j });\n            }\n        }\n    }\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    else return dist[n];\n}\n```\n\n\n\n### Spfa算法\n\n可用于负权图\n\n```c++\ndist[j] = dist[t] + w[i] //当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边\n```\n\n\n\n```c++\nint spfa(){\n    queue<PII> q;\n    memset(dist,0x3f,sizeof dist);\n    dist[1]=0;\n    q.push({0,1});\n    st[1]=true;\n    while(q.size()){\n        PII p=q.front();\n        q.pop();\n        int t=p.se;\n        st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队\n        for(int i=h[t];i!=-1;i=ne[i]){\n            int j=e[i];\n            if(dist[j]>dist[t]+w[i]){\n                dist[j]=dist[t]+w[i];\n                if(!st[j]){//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率\n                    st[j]=true;\n                    q.push({dist[j],j});\n                }\n            }\n        }\n    }\n    if(dist[n]==0x3f3f3f3f) return -1;\n    else return dist[n];\n}\n```\n\n\n\n如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。\n\n```c++\nbool spfa() {\n\tqueue<int> q;\n\n\tfor (int i = 1; i <= n; i ++) {//需要判断的是有无负权回路，则应该是从每个点开始遍历\n\t\tq.push(i);\n\t\tst[i] = true;\n\t}\n\n\twhile (q.size()) {\n\t\tint t = q.front();\n\n\t\tq.pop();\n\t\tst[t] = false;\n\n\t\tfor (int i = h[t]; i != -1; i = ne[i]) {\n\t\t\tint j = e[i];\n\t\t\tif (dist[j] > dist[t] + w[i]) {\n\t\t\t\tdist[j] = dist[t] + w[i];\n\t\t\t\tcnt[j] = cnt[t] + 1;\n\t\t\t\tif (cnt[j] > n)\n\t\t\t\t\treturn true;\n\t\t\t\tif (!st[j]) {\n\t\t\t\t\tst[j] = true;\n\t\t\t\t\tq.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n\n\n```c++\nvoid spfa() {\t\t//从 start 到 ed 的最小权重\n\tmemset(dist, 0x3f, sizeof dist);\n\n\tdist[start] = 0;\n\n\tq[0] = start, st[start] = true;\n\n\tint hh = 0, tt = 1;\n\twhile (hh != tt) {\n\t\tint t = q[hh ++];\n\t\tif (hh == N)\t\t\n\t\t\thh = 0;\n\t\tst[t] = false;\n\n\t\tfor (int i = h[t]; i != -1; i = ne[i]) {\n\t\t\tint j = e[i];\n\t\t\tif (dist[j] > dist[t] + w[i]) {\n\t\t\t\tdist[j] = dist[t] + w[i];\n\t\t\t\tif (!st[j]) {\n\t\t\t\t\tq[tt ++] = j;\n\t\t\t\t\tif (tt == N)\n\t\t\t\t\t\ttt = 0;\n\t\t\t\t\tst[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n### Bellman_ford算法\n\n可用于负权回路图。\n\n1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路\n\n核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f / 2 ，即无法用 k 步走到 n 点\n\n```c++\nint bellman_ford() {\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i < k; i++) {//k次循环\n        memcpy(back, dist, sizeof dist);\n        for (int j = 0; j < m; j++) {//遍历所有边\n            int a = e[j].a, b = e[j].b, w = e[j].w;\n            dist[b] = min(dist[b], back[a] + w);\n            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来\n        }\n    }\n    if (dist[n] > 0x3f3f3f3f / 2) return -1;\n    else return dist[n];\n\n}\n```\n\n### Prim算法\n\n题型：**稠密图**，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）\n\n思想：从 n 个点中选出一个离当前生成树的最小路径，res +=该路径，并且用这个点更新其余的点（ dist[ j ] = min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] = INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。\n\n```c++\nint Prim() {\n\tmemset(dist, 0x3f, sizeof dist);\n\t//dist[j]： 点j到目前生成树的距离\n\tint res = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tint t = -1;\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (!st[j] && (t == -1 || dist[j] < dist[t]))\n\t\t\t\tt = j;\n\t\t}\n\n\t\tif (i)\n\t\t\tres += dist[t];\n\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tdist[j] = min(dist[j], g[t][j]);\n\t\t}\n\n\t\tif (i && dist[t] == INF)\n\t\t\treturn INF;\n\t\tst[t] = true;\n\t}\n\treturn res;\n}\n```\n\n### Kruskal算法\n\n题型：**稀疏图**，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）\n\n思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res += 边权值，cnt ++。 \n\n```c++\nint main(){\nsort(edges, edges + m, cmp);\n\n\tint res = 0, cnt = 0;\n\tfor (int i = 0; i < m; i ++) {\n\t\tint a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n\t\ta = find(a), b = find(b);\n\t\tif (a != b) {\n\t\t\tres += w;\n\t\t\tcnt ++;\n\t\t\tp[a] = b;\n\t\t}\n\t}\n\n\tif (cnt < n - 1)//边数小于 n - 1 说明有孤立点 \n\t\tprintf(\"impossible\");\n\telse\n\t\tprintf(\"%d\", res);\n}\n```\n\n### 染色法判定二分图\n\n题型：判断二分图\n\n思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图\n\n```c++\nbool DFS(int u, int c) {\n    color[u] = c;\n\tfor (int i = h[u]; i != -1; i = ne[i]) {\n\t\tint j = e[i];\n\t\tif (!color[j]) {\n\t\t\tif (!DFS(j, 3 - c))\n\t\t\t\treturn false;\n\t\t} else if (color[j] == c)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n    bool flag = true;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (!color[i]) {\n\t\t\tif (!DFS(i, 1)) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flag)\n\t\tprintf(\"Yes\");\n\telse\n\t\tprintf(\"No\");\n}\n```\n\n### 匈牙利算法\n\n题型：邻接表，求二分图的最大匹配\n\n思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配），\n\n如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] = x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。\n\n```c++\nbool find(int x) {\t\t\t//帮助男生 x 匹配女生，成功返回true，否则返回false\n\tfor (int i = h[x]; i != -1; i = ne[i]) {\n\t\tint j = e[i];\n\t\tif (!st[j]) {\n\t\t\tst[j] = true;\n\t\t\tif (match[j] == 0 || find(match[j])) {\n\t\t\t\tmatch[j] = x;\t\t//match[j]代表 女生 j 的匹配的男生为 match[j]\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n    for (int i = 1; i <= n1; i ++) {\n\t\tmemset(st, false, sizeof st);\n\t\tif (find(i))\n\t\t\tres ++;\n\t}\n}\n```\n\n## 数位Dp\n\n把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算\n\n```c++\nint dp(int n){\n    if (n == 0) return 0;\n\n    vector<int> nums;\n    while(n) nums.push_back(n % B), n /= B;\n\n    int res = 0, last = 0;\n    for (int i = nums.size() - 1; i >= 0; i -- ){\n        int x = nums[i];\n\n    }\n    return res;\n}\n```\n\n## 树的最长路径\n\n```c++\nvoid dfs(int u, int father)//防止从下往上遍历，引入 father\n{\n    f1[u] = f2[u] = 0;//从 u 点出发， f1 为最长的路径， f2 为第二长的路径\n    for (int i = h[u]; ~i; i = ne[i])\n    {\n        int j = e[i];\n        if (j == father) continue;\n        dfs(j, u);\n        if (f1[j] + w[i] >= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; //最长路转移\n        else if (f1[j] + w[i] > f2[u]) f2[u] = f1[j] + w[i];            //次长路转移\n    }\n    res = max(res, f1[u] + f2[u]);\n}\n```\n\n## Flood Fill\n\n求连通块的数量\n\n```c++\nvoid bfs(int sx, int sy){\n    st[sx][sy] = true;\n    q[0] = {sx, sy};\n\n    int hh = 0, tt = 0;\n    while(hh <= tt){\n        PII t = q[hh ++];\n        for (int i = t.x - 1; i <= t.x + 1; i ++ )\n            for (int j = t.y - 1; j <= t.y + 1; j ++ ){\n                if (i == t.x && j == t.y) continue;\n                if (g[i][j] == '.' || st[i][j]) continue;\n                if (i < 0 || i >= n || j < 0 || j >= m) continue;\n                q[ ++ tt] = {i, j};\n                st[i][j] = true;\n            }\n    }\n}\n\nint cnt = 0;\n    for (int i = 0; i < n; i ++ )\n        for (int j = 0; j < m; j ++ ){\n            if (g[i][j] == 'W' && !st[i][j]){ //需要联通的条件，并且该点没有遍历\n                bfs(i, j);\n                cnt ++;\n            }\n        }\n```\n\n```c++\nint bfs(){\t//求最短路径\n    memset(dist, -1, sizeof dist);//定义所有点都没有遍历\n    \n    int sx, sy;\n    for (int i = 0; i < n; i ++ )\n        for (int j = 0; j < m; j ++ )\n            if (g[i][j] == 'K'){\n                sx = i, sy = j;\n            }\n    \n    int hh = 0, tt = 0;\n    q[0] = {sx, sy};\n    dist[sx][sy] = 0;//起始点的距离为0\n    while(hh <= tt){\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i < 8; i ++ ){\n            int a = t.x + dx[i], b = t.y + dy[i];//枚举下一个点\n            if (a < 0 || a >= n || b < 0 || b >= m) continue;\n            if (g[a][b] == '*') continue;\n            if (dist[a][b] != -1) continue;//表示下一个点有没有遍历\n            if (g[a][b] == 'H') return dist[t.x][t.y] + 1;\n\n            dist[a][b] = dist[t.x][t.y] + 1;\n            q[ ++ tt] = {a, b};\n        }\n    }\n}\n```\n\n```c++\nvoid bfs(int sx, int sy){//求最短路径，并且输出路径\n    int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\n    int hh = 0, tt = 0;\n    q[0] = {sx, sy};\n\n    memset(pre, -1, sizeof pre);//pre 用于存储路径\n    pre[sx][sy] = {0, 0};\n//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的\n    while (hh <= tt){\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i < 4; i ++ ){\n            int a = t.x + dx[i], b = t.y + dy[i];\n            if (a < 0 || a >= n || b < 0 || b >= n) continue;\n            if (g[a][b]) continue;\n            if (pre[a][b].x != -1) continue;\n\n            q[ ++ tt] = {a, b};\n            pre[a][b] = t;\n        }\n    }\n}\n```\n\n## 数学知识\n\n### 线性筛法求素数 \n\n```c++\nint primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n{\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n```\n\n### 欧几里得算法\n\n```c++\nint gcd(int a, int b)//求最大公约数\n{\n    return b ? gcd(b, a % b) : a;\n}\n```\n\n### 试除法求所有约数\n\n```c++\nvector<int> get_divisors(int x)\n{\n    vector<int> res;\n    for (int i = 1; i <= x / i; i ++ )\n        if (x % i == 0)\n        {\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);//防止相同的数\n        }\n    sort(res.begin(), res.end());\n    return res;\n}\n```\n\n### 筛法求欧拉函数\n\n```c++\nint primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n{\n    euler[1] = 1;\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i])\n        {\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        }\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            {\n                euler[t] = euler[i] * primes[j];\n                break;\n            }\n            euler[t] = euler[i] * (primes[j] - 1);\n        }\n    }\n}\n```\n\n### 快速幂\n\n```c++\nint qmi(int m, int k, int p)\n{\n    int res = 1 % p, t = m;\n    while (k)\n    {\n        if (k & 1) res = res * t % p;\n        t = t * t % p;\n        k >>= 1;\n    }\n    return res;\n}\n```\n\n### 扩展欧几里得算法\n\n```c++\n// 求x, y，使得ax + by = gcd(a, b)\nint exgcd(int a, int b, int &x, int &y)\n{\n    if (!b)\n    {\n        x = 1; y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;\n    return d;\n}\n```\n\n","slug":"算法笔记","published":true,"updated":"2023-12-16T13:27:30.879Z","_id":"clq9fmlck000e4otf5t0uep6k","comments":true,"layout":"post","photos":[],"link":"","html":"<h2 id=\"C-头文件\"><a href=\"#C-头文件\" class=\"headerlink\" title=\"C++头文件\"></a>C++头文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; PII</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; alls;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"string-的函数\"><a href=\"#string-的函数\" class=\"headerlink\" title=\"string 的函数\"></a>string 的函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    a.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, k) <span class=\"comment\">//从 a[0] 开始到 a[k] ，返回这段字符串</span></span><br><span class=\"line\">    a.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>)  <span class=\"comment\">//从 a[1] 开始到末尾，返回这段字符串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"排列组合\"><a href=\"#排列组合\" class=\"headerlink\" title=\"排列组合\"></a>排列组合</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192125061.png\" alt=\"image-20221215192125061\"><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192152255.png\" alt=\"image-20221215192152255\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从m个数里抽出n个数，进行全排列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">arrange</span><span class=\"params\">(<span class=\"type\">int</span> m,<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m==n)<span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m*<span class=\"built_in\">arrange</span>(m<span class=\"number\">-1</span>,n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从m个数里抽出n个数，进行组合排序</span></span><br><span class=\"line\"><span class=\"comment\">//法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cnm</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m*<span class=\"built_in\">cnm</span>(n<span class=\"number\">-1</span>,m<span class=\"number\">-1</span>)/n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//法二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cnm</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==m)<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">cnm</span>(n,m<span class=\"number\">-1</span>)+<span class=\"built_in\">cnm</span>(n<span class=\"number\">-1</span>,m<span class=\"number\">-1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//法三  从 i 个数里抽出 j 个数的方案数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= i; j ++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!j) f[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> f[i][j] = f[i - <span class=\"number\">1</span>][j] + f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二位前缀和\"><a href=\"#二位前缀和\" class=\"headerlink\" title=\"二位前缀和\"></a>二位前缀和</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230314194756707.png\" alt=\"image-20230314194756707\"></p>\n<h2 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h2><p>在数组a[l,r]区间内加上c，则可表示为a[l]+&#x3D;c,a[r+1]+&#x3D;-c</p>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>x&gt;&gt;1，代表x右移一位，值变成1&#x2F;2；x&lt;&lt;1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。</p>\n<p>x &gt;&gt; k &amp; 1 , 代表 x 的第 k 位是否为 1.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;\t\t\t<span class=\"comment\">//返回最后一个1的位数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x&amp;-x;\t\t\t<span class=\"comment\">/*例如 10 的二进制为 1010，则返回 10*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; alls;<span class=\"comment\">//储存所有待离散化的值</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span>(alls.<span class=\"built_in\">begin</span>(),alls.<span class=\"built_in\">end</span>());<span class=\"comment\">//将所有的值排序</span></span><br><span class=\"line\">alls.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(alls.<span class=\"built_in\">begin</span>(),alls,end),alls.end);<span class=\"comment\">//去掉重复元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二分法求出x对应的离散化的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = alls.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = l + r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(alls[mid] &gt;= x)&#123;</span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            l = mid +<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span>;<span class=\"comment\">//返回 1，2，3，4……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">100010</span>, M = <span class=\"number\">10010</span>; <span class=\"comment\">//N为模式串长度，M匹配串长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">int</span> ne[M]; <span class=\"comment\">//next[]数组，避免和头文件next冲突</span></span><br><span class=\"line\"><span class=\"type\">char</span> s[N], p[M];  <span class=\"comment\">//s为模式串， p为匹配串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; s+<span class=\"number\">1</span> &gt;&gt; m &gt;&gt; p+<span class=\"number\">1</span>;  <span class=\"comment\">//下标从1开始</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//求next[]数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>, j = <span class=\"number\">0</span>; i &lt;= m; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &amp;&amp; p[i] != p[j+<span class=\"number\">1</span>]) j = ne[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p[i] == p[j+<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">        ne[i] = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//匹配操作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &amp;&amp; s[i] != p[j+<span class=\"number\">1</span>]) j = ne[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == p[j+<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == m)  <span class=\"comment\">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//匹配完成后的具体操作</span></span><br><span class=\"line\">            <span class=\"comment\">//如：输出以0开始的匹配子串的首字母下标</span></span><br><span class=\"line\">            <span class=\"comment\">//printf(&quot;%d &quot;, i - m); (若从1开始，加1)</span></span><br><span class=\"line\">            j = ne[j];            <span class=\"comment\">//再次继续匹配</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230317125934107.png\" alt=\"image-20230317125934107\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">100010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> son[N][<span class=\"number\">26</span>], cnt[N], idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> str[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; str[i]; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> u = str[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (son[p][u] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tson[p][u] = ++idx;</span><br><span class=\"line\">\t\tp = son[p][u];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[p]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> str[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; str[i]; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> u = str[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (son[p][u] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tp = son[p][u];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt[p];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//返回x的祖宗节点，并压缩路径</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p[x] != x)p[x] = <span class=\"built_in\">find</span>(p[x]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果要合并两个节点，则</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步</span></span><br><span class=\"line\">    size[<span class=\"built_in\">find</span>(b)] += size[<span class=\"built_in\">find</span>(a)];  <span class=\"comment\">//必须先加size，再合并（a,b）</span></span><br><span class=\"line\">    p[<span class=\"built_in\">find</span>(a)] = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">    <span class=\"comment\">//加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义</span></span><br><span class=\"line\">    <span class=\"comment\">//如果先合并再相加，则代表两个相同的集合数量相加</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span> + <span class=\"number\">3</span>;\t\t\t\t<span class=\"comment\">//大于数据范围的第一个质数</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> null = <span class=\"number\">0x3f3f3f3f</span>;\t\t<span class=\"comment\">//规定空指针为 null 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> h[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t = (x % N + N) % N;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (h[t] != null &amp;&amp; h[t] != x) &#123;</span><br><span class=\"line\">\t\tt++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (t == N) &#123;</span><br><span class=\"line\">\t\t\tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t;\t<span class=\"comment\">//如果这个位置是空的, 则返回的是他应该存储的位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(h, null, <span class=\"built_in\">sizeof</span>(h));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n --) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> op[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;I&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\th[<span class=\"built_in\">find</span>(x)] = x;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[<span class=\"built_in\">find</span>(x)] == null) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串哈希表\"><a href=\"#字符串哈希表\" class=\"headerlink\" title=\"字符串哈希表\"></a>字符串哈希表</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230318194927056.png\" alt=\"image-20230318194927056\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ULL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"type\">const</span> N = <span class=\"number\">10000010</span>, P = <span class=\"number\">131</span>; <span class=\"comment\">//P = 131 或者是 13331 Q一般取 2^64</span></span><br><span class=\"line\"><span class=\"comment\">// P 代表进制 </span></span><br><span class=\"line\"></span><br><span class=\"line\">ULL h[N], p[N];</span><br><span class=\"line\"><span class=\"type\">char</span> a[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ULL <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, a + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\th[<span class=\"number\">0</span>] = <span class=\"number\">0</span>, p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) &#123;</span><br><span class=\"line\">\t\th[i] = h[i - <span class=\"number\">1</span>] * P + a[i];</span><br><span class=\"line\">\t\tp[i] = p[i - <span class=\"number\">1</span>] * P;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l1, l2, r1, r2;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d %d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">query</span>(l1, r1) == <span class=\"built_in\">query</span>(l2, r2))</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230323161436730.png\" alt=\"image-20230323161436730\"></p>\n<h2 id=\"最小根堆\"><a href=\"#最小根堆\" class=\"headerlink\" title=\"最小根堆\"></a>最小根堆</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#icnlude <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;, greater&lt;<span class=\"type\">int</span>&gt;&gt; heap;</span><br><span class=\"line\">heap.<span class=\"built_in\">push</span>(x), x = heap.<span class=\"built_in\">top</span>(), heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"><span class=\"comment\">//每次弹出来的顶端都是最小值，并且push后堆会自动排序</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于sort-函数\"><a href=\"#关于sort-函数\" class=\"headerlink\" title=\"关于sort()函数\"></a>关于sort()函数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b;\t\t\t\t\t\t\t\t <span class=\"comment\">//a&gt;b为由大到小，b&lt;a为由小到大</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sort(num,num+<span class=\"number\">100</span>,cmp);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a, b , w;</span><br><span class=\"line\">&#125;edges[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge a, Edge b)</span></span>&#123;\t\t\t\t\t\t<span class=\"comment\">//按照w的大小排序，此时为递增</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sort</span>(edges, edges + m, cmp);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以自定义排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;\t\t\t\t\t<span class=\"comment\">//按照个位数的大小排序，此时为递增</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x % <span class=\"number\">10</span> &lt; y % <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>sort(首地址，尾地址+1，cmp)</li>\n<li>这个函数可以传两个或者三个参数</li>\n<li>第一个参数是要排序的区间首地址</li>\n<li>第二个参数是区间尾地址的下一个地址</li>\n<li>第三个参数不写,则为递增排序</li>\n</ol>\n<h2 id=\"求最大公约数、最小公倍数\"><a href=\"#求最大公约数、最小公倍数\" class=\"headerlink\" title=\"求最大公约数、最小公倍数\"></a>求最大公约数、最小公倍数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;\t<span class=\"comment\">//最大公约数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b ? <span class=\"built_in\">gcd</span>(b, a % b) : a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcb</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;\t<span class=\"comment\">//最小公倍数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b / <span class=\"built_in\">gcd</span>(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取模\"><a href=\"#取模\" class=\"headerlink\" title=\"取模\"></a>取模</h2><p>同余定理：x%mod&#x3D;(x+mod)%mod</p>\n<h2 id=\"无穷大\"><a href=\"#无穷大\" class=\"headerlink\" title=\"无穷大\"></a>无穷大</h2><p>inf &#x3D; 0x3f3f3f3f</p>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223240363.png\" alt=\"image-20230406223240363\"></p>\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223251946.png\" alt=\"image-20230406223251946\"></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[N], tmp[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">merge_sort</span>(l, mid), <span class=\"built_in\">merge_sort</span>(mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"number\">0</span>, i = l, j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] &lt;= a[j]) tmp[k ++] = a[i ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> tmp[k ++] = a[j ++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt;= mid) tmp[k ++] = a[i ++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(j &lt;= r) tmp[k ++] = a[j ++];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l, j = <span class=\"number\">0</span>; i &lt;= r; i ++, j ++) a[i] = tmp[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h2><p>初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> e[N], ne[N], h[N], w[N], dist[N], idx;</span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">\te[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h3><p>朴素版</p>\n<p>题型：稠密图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dist));</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[j] &lt; dist[t]))</span><br><span class=\"line\">                t = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">            dist[j] = <span class=\"built_in\">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>堆优化</p>\n<p>题型：稀疏图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dist));</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class=\"comment\">// 定义一个小根堆</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，</span></span><br><span class=\"line\">    <span class=\"comment\">// 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span></span><br><span class=\"line\">    heap.<span class=\"built_in\">push</span>(&#123; <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;); <span class=\"comment\">// 这个顺序不能倒，pair排序时是先根据first，再根据second，</span></span><br><span class=\"line\">                         <span class=\"comment\">// 这里显然要根据距离排序</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(heap.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PII k = heap.<span class=\"built_in\">top</span>(); <span class=\"comment\">// 取不在集合S中距离最短的点</span></span><br><span class=\"line\">        heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> ver = k.second, distance = k.first;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st[ver]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        st[ver] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = h[ver]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = e[i]; <span class=\"comment\">// i只是个下标，e中在存的是i这个下标对应的点。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[j] &gt; distance + w[i])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dist[j] = distance + w[i];</span><br><span class=\"line\">                heap.<span class=\"built_in\">push</span>(&#123; dist[j], j &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Spfa算法\"><a href=\"#Spfa算法\" class=\"headerlink\" title=\"Spfa算法\"></a>Spfa算法</h3><p>可用于负权图</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dist[j] = dist[t] + w[i] <span class=\"comment\">//当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    queue&lt;PII&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    st[<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        PII p=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> t=p.se;</span><br><span class=\"line\">        st[t]=<span class=\"literal\">false</span>;<span class=\"comment\">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h[t];i!=<span class=\"number\">-1</span>;i=ne[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j=e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class=\"line\">                dist[j]=dist[t]+w[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st[j])&#123;<span class=\"comment\">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class=\"line\">                    st[j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(&#123;dist[j],j&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n]==<span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tqueue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) &#123;<span class=\"comment\">//需要判断的是有无负权回路，则应该是从每个点开始遍历</span></span><br><span class=\"line\">\t\tq.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t\tst[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tst[t] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[t]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[j] = dist[t] + w[i];</span><br><span class=\"line\">\t\t\t\tcnt[j] = cnt[t] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cnt[j] &gt; n)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!st[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tst[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(j);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;\t\t<span class=\"comment\">//从 start 到 ed 的最小权重</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\"></span><br><span class=\"line\">\tdist[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tq[<span class=\"number\">0</span>] = start, st[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (hh != tt) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = q[hh ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (hh == N)\t\t</span><br><span class=\"line\">\t\t\thh = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tst[t] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[t]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[j] = dist[t] + w[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!st[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tq[tt ++] = j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (tt == N)</span><br><span class=\"line\">\t\t\t\t\t\ttt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\tst[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Bellman-ford算法\"><a href=\"#Bellman-ford算法\" class=\"headerlink\" title=\"Bellman_ford算法\"></a>Bellman_ford算法</h3><p>可用于负权回路图。</p>\n<p>1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路</p>\n<p>核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f &#x2F; 2 ，即无法用 k 步走到 n 点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bellman_ford</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;<span class=\"comment\">//k次循环</span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(back, dist, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;<span class=\"comment\">//遍历所有边</span></span><br><span class=\"line\">            <span class=\"type\">int</span> a = e[j].a, b = e[j].b, w = e[j].w;</span><br><span class=\"line\">            dist[b] = <span class=\"built_in\">min</span>(dist[b], back[a] + w);</span><br><span class=\"line\">            <span class=\"comment\">//使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] &gt; <span class=\"number\">0x3f3f3f3f</span> / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>题型：<strong>稠密图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：从 n 个点中选出一个离当前生成树的最小路径，res +&#x3D;该路径，并且用这个点更新其余的点（ dist[ j ] &#x3D; min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] &#x3D; INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Prim</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">\t<span class=\"comment\">//dist[j]： 点j到目前生成树的距离</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!st[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[j] &lt; dist[t]))</span><br><span class=\"line\">\t\t\t\tt = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i)</span><br><span class=\"line\">\t\t\tres += dist[t];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++) &#123;</span><br><span class=\"line\">\t\t\tdist[j] = <span class=\"built_in\">min</span>(dist[j], g[t][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &amp;&amp; dist[t] == INF)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> INF;</span><br><span class=\"line\">\t\tst[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>题型：<strong>稀疏图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res +&#x3D; 边权值，cnt ++。 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(edges, edges + m, cmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> res = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ta = <span class=\"built_in\">find</span>(a), b = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a != b) &#123;</span><br><span class=\"line\">\t\t\tres += w;</span><br><span class=\"line\">\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\tp[a] = b;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt &lt; n - <span class=\"number\">1</span>)<span class=\"comment\">//边数小于 n - 1 说明有孤立点 </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;impossible&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"染色法判定二分图\"><a href=\"#染色法判定二分图\" class=\"headerlink\" title=\"染色法判定二分图\"></a>染色法判定二分图</h3><p>题型：判断二分图</p>\n<p>思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    color[u] = c;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[u]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!color[j]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">DFS</span>(j, <span class=\"number\">3</span> - c))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (color[j] == c)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!color[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">DFS</span>(i, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h3><p>题型：邻接表，求二分图的最大匹配</p>\n<p>思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配），</p>\n<p>如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] &#x3D; x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;\t\t\t<span class=\"comment\">//帮助男生 x 匹配女生，成功返回true，否则返回false</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[x]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!st[j]) &#123;</span><br><span class=\"line\">\t\t\tst[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (match[j] == <span class=\"number\">0</span> || <span class=\"built_in\">find</span>(match[j])) &#123;</span><br><span class=\"line\">\t\t\t\tmatch[j] = x;\t\t<span class=\"comment\">//match[j]代表 女生 j 的匹配的男生为 match[j]</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n1; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(st, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span> st);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find</span>(i))</span><br><span class=\"line\">\t\t\tres ++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数位Dp\"><a href=\"#数位Dp\" class=\"headerlink\" title=\"数位Dp\"></a>数位Dp</h2><p>把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; nums;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n) nums.<span class=\"built_in\">push_back</span>(n % B), n /= B;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>, last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- )&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"树的最长路径\"><a href=\"#树的最长路径\" class=\"headerlink\" title=\"树的最长路径\"></a>树的最长路径</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> father)</span><span class=\"comment\">//防止从下往上遍历，引入 father</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    f1[u] = f2[u] = <span class=\"number\">0</span>;<span class=\"comment\">//从 u 点出发， f1 为最长的路径， f2 为第二长的路径</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == father) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(j, u);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f1[j] + w[i] &gt;= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; <span class=\"comment\">//最长路转移</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f1[j] + w[i] &gt; f2[u]) f2[u] = f1[j] + w[i];            <span class=\"comment\">//次长路转移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res = <span class=\"built_in\">max</span>(res, f1[u] + f2[u]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flood-Fill\"><a href=\"#Flood-Fill\" class=\"headerlink\" title=\"Flood Fill\"></a>Flood Fill</h2><p>求连通块的数量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy)</span></span>&#123;</span><br><span class=\"line\">    st[sx][sy] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    q[<span class=\"number\">0</span>] = &#123;sx, sy&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(hh &lt;= tt)&#123;</span><br><span class=\"line\">        PII t = q[hh ++];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = t.x - <span class=\"number\">1</span>; i &lt;= t.x + <span class=\"number\">1</span>; i ++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = t.y - <span class=\"number\">1</span>; j &lt;= t.y + <span class=\"number\">1</span>; j ++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == t.x &amp;&amp; j == t.y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g[i][j] == <span class=\"string\">&#x27;.&#x27;</span> || st[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= n || j &lt; <span class=\"number\">0</span> || j &gt;= m) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                q[ ++ tt] = &#123;i, j&#125;;</span><br><span class=\"line\">                st[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j ++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[i][j] == <span class=\"string\">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])&#123; <span class=\"comment\">//需要联通的条件，并且该点没有遍历</span></span><br><span class=\"line\">                <span class=\"built_in\">bfs</span>(i, j);</span><br><span class=\"line\">                cnt ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;\t<span class=\"comment\">//求最短路径</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> dist);<span class=\"comment\">//定义所有点都没有遍历</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> sx, sy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j ++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[i][j] == <span class=\"string\">&#x27;K&#x27;</span>)&#123;</span><br><span class=\"line\">                sx = i, sy = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q[<span class=\"number\">0</span>] = &#123;sx, sy&#125;;</span><br><span class=\"line\">    dist[sx][sy] = <span class=\"number\">0</span>;<span class=\"comment\">//起始点的距离为0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(hh &lt;= tt)&#123;</span><br><span class=\"line\">        PII t = q[hh ++ ];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i ++ )&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = t.x + dx[i], b = t.y + dy[i];<span class=\"comment\">//枚举下一个点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span> || a &gt;= n || b &lt; <span class=\"number\">0</span> || b &gt;= m) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[a][b] == <span class=\"string\">&#x27;*&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[a][b] != <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//表示下一个点有没有遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[a][b] == <span class=\"string\">&#x27;H&#x27;</span>) <span class=\"keyword\">return</span> dist[t.x][t.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            dist[a][b] = dist[t.x][t.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            q[ ++ tt] = &#123;a, b&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy)</span></span>&#123;<span class=\"comment\">//求最短路径，并且输出路径</span></span><br><span class=\"line\">    <span class=\"type\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q[<span class=\"number\">0</span>] = &#123;sx, sy&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> pre);<span class=\"comment\">//pre 用于存储路径</span></span><br><span class=\"line\">    pre[sx][sy] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (hh &lt;= tt)&#123;</span><br><span class=\"line\">        PII t = q[hh ++ ];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i ++ )&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span> || a &gt;= n || b &lt; <span class=\"number\">0</span> || b &gt;= n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[a][b]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre[a][b].x != <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            q[ ++ tt] = &#123;a, b&#125;;</span><br><span class=\"line\">            pre[a][b] = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h2><h3 id=\"线性筛法求素数\"><a href=\"#线性筛法求素数\" class=\"headerlink\" title=\"线性筛法求素数\"></a>线性筛法求素数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> primes[N], cnt;     <span class=\"comment\">// primes[]存储所有素数</span></span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];         <span class=\"comment\">// st[x]存储x是否被筛掉</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_primes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            st[primes[j] * i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % primes[j] == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span><span class=\"comment\">//求最大公约数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b ? <span class=\"built_in\">gcd</span>(b, a % b) : a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"试除法求所有约数\"><a href=\"#试除法求所有约数\" class=\"headerlink\" title=\"试除法求所有约数\"></a>试除法求所有约数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">get_divisors</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= x / i; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != x / i) res.<span class=\"built_in\">push_back</span>(x / i);<span class=\"comment\">//防止相同的数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛法求欧拉函数\"><a href=\"#筛法求欧拉函数\" class=\"headerlink\" title=\"筛法求欧拉函数\"></a>筛法求欧拉函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> primes[N], cnt;     <span class=\"comment\">// primes[]存储所有素数</span></span><br><span class=\"line\"><span class=\"type\">int</span> euler[N];           <span class=\"comment\">// 存储每个数的欧拉函数</span></span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];         <span class=\"comment\">// st[x]存储x是否被筛掉</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_eulers</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    euler[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            primes[cnt ++ ] = i;</span><br><span class=\"line\">            euler[i] = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = primes[j] * i;</span><br><span class=\"line\">            st[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % primes[j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                euler[t] = euler[i] * primes[j];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            euler[t] = euler[i] * (primes[j] - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> k, <span class=\"type\">int</span> p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">1</span> % p, t = m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>) res = res * t % p;</span><br><span class=\"line\">        t = t * t % p;</span><br><span class=\"line\">        k &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a>扩展欧几里得算法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">exgcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> &amp;x, <span class=\"type\">int</span> &amp;y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>; y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> d = <span class=\"built_in\">exgcd</span>(b, a % b, y, x);</span><br><span class=\"line\">    y -= (a/b) * x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<h2 id=\"C-头文件\"><a href=\"#C-头文件\" class=\"headerlink\" title=\"C++头文件\"></a>C++头文件</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unordered_map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; PII</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; alls;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"string-的函数\"><a href=\"#string-的函数\" class=\"headerlink\" title=\"string 的函数\"></a>string 的函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    string a;</span><br><span class=\"line\">    a.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, k) <span class=\"comment\">//从 a[0] 开始到 a[k] ，返回这段字符串</span></span><br><span class=\"line\">    a.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>)  <span class=\"comment\">//从 a[1] 开始到末尾，返回这段字符串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"排列组合\"><a href=\"#排列组合\" class=\"headerlink\" title=\"排列组合\"></a>排列组合</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192125061.png\" alt=\"image-20221215192125061\"><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192152255.png\" alt=\"image-20221215192152255\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从m个数里抽出n个数，进行全排列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">arrange</span><span class=\"params\">(<span class=\"type\">int</span> m,<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m==n)<span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m*<span class=\"built_in\">arrange</span>(m<span class=\"number\">-1</span>,n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//从m个数里抽出n个数，进行组合排序</span></span><br><span class=\"line\"><span class=\"comment\">//法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cnm</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> m*<span class=\"built_in\">cnm</span>(n<span class=\"number\">-1</span>,m<span class=\"number\">-1</span>)/n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//法二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">cnm</span><span class=\"params\">(<span class=\"type\">int</span> n,<span class=\"type\">int</span> m)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)<span class=\"keyword\">return</span> m;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n==m)<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"built_in\">cnm</span>(n,m<span class=\"number\">-1</span>)+<span class=\"built_in\">cnm</span>(n<span class=\"number\">-1</span>,m<span class=\"number\">-1</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//法三  从 i 个数里抽出 j 个数的方案数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; N; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt;= i; j ++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!j) f[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> f[i][j] = f[i - <span class=\"number\">1</span>][j] + f[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二位前缀和\"><a href=\"#二位前缀和\" class=\"headerlink\" title=\"二位前缀和\"></a>二位前缀和</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230314194756707.png\" alt=\"image-20230314194756707\"></p>\n<h2 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h2><p>在数组a[l,r]区间内加上c，则可表示为a[l]+&#x3D;c,a[r+1]+&#x3D;-c</p>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>x&gt;&gt;1，代表x右移一位，值变成1&#x2F;2；x&lt;&lt;1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。</p>\n<p>x &gt;&gt; k &amp; 1 , 代表 x 的第 k 位是否为 1.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">lowbit</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;\t\t\t<span class=\"comment\">//返回最后一个1的位数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x&amp;-x;\t\t\t<span class=\"comment\">/*例如 10 的二进制为 1010，则返回 10*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; alls;<span class=\"comment\">//储存所有待离散化的值</span></span><br><span class=\"line\"><span class=\"built_in\">sort</span>(alls.<span class=\"built_in\">begin</span>(),alls.<span class=\"built_in\">end</span>());<span class=\"comment\">//将所有的值排序</span></span><br><span class=\"line\">alls.<span class=\"built_in\">erase</span>(<span class=\"built_in\">unique</span>(alls.<span class=\"built_in\">begin</span>(),alls,end),alls.end);<span class=\"comment\">//去掉重复元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//二分法求出x对应的离散化的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = alls.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = l + r;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(alls[mid] &gt;= x)&#123;</span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            l = mid +<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r + <span class=\"number\">1</span>;<span class=\"comment\">//返回 1，2，3，4……</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">100010</span>, M = <span class=\"number\">10010</span>; <span class=\"comment\">//N为模式串长度，M匹配串长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">int</span> ne[M]; <span class=\"comment\">//next[]数组，避免和头文件next冲突</span></span><br><span class=\"line\"><span class=\"type\">char</span> s[N], p[M];  <span class=\"comment\">//s为模式串， p为匹配串</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cin &gt;&gt; n &gt;&gt; s+<span class=\"number\">1</span> &gt;&gt; m &gt;&gt; p+<span class=\"number\">1</span>;  <span class=\"comment\">//下标从1开始</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//求next[]数组</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>, j = <span class=\"number\">0</span>; i &lt;= m; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &amp;&amp; p[i] != p[j+<span class=\"number\">1</span>]) j = ne[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p[i] == p[j+<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">        ne[i] = j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//匹配操作</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j &amp;&amp; s[i] != p[j+<span class=\"number\">1</span>]) j = ne[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s[i] == p[j+<span class=\"number\">1</span>]) j++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(j == m)  <span class=\"comment\">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//匹配完成后的具体操作</span></span><br><span class=\"line\">            <span class=\"comment\">//如：输出以0开始的匹配子串的首字母下标</span></span><br><span class=\"line\">            <span class=\"comment\">//printf(&quot;%d &quot;, i - m); (若从1开始，加1)</span></span><br><span class=\"line\">            j = ne[j];            <span class=\"comment\">//再次继续匹配</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230317125934107.png\" alt=\"image-20230317125934107\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">100010</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> son[N][<span class=\"number\">26</span>], cnt[N], idx = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"type\">char</span> str[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; str[i]; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> u = str[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (son[p][u] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tson[p][u] = ++idx;</span><br><span class=\"line\">\t\tp = son[p][u];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcnt[p]++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">char</span> str[])</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; str[i]; i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> u = str[i] - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (son[p][u] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tp = son[p][u];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cnt[p];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span><span class=\"comment\">//返回x的祖宗节点，并压缩路径</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p[x] != x)p[x] = <span class=\"built_in\">find</span>(p[x]);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p[x];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果要合并两个节点，则</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步</span></span><br><span class=\"line\">    size[<span class=\"built_in\">find</span>(b)] += size[<span class=\"built_in\">find</span>(a)];  <span class=\"comment\">//必须先加size，再合并（a,b）</span></span><br><span class=\"line\">    p[<span class=\"built_in\">find</span>(a)] = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">    <span class=\"comment\">//加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义</span></span><br><span class=\"line\">    <span class=\"comment\">//如果先合并再相加，则代表两个相同的集合数量相加</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">2e5</span> + <span class=\"number\">3</span>;\t\t\t\t<span class=\"comment\">//大于数据范围的第一个质数</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> null = <span class=\"number\">0x3f3f3f3f</span>;\t\t<span class=\"comment\">//规定空指针为 null 0x3f3f3f3f</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> h[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> t = (x % N + N) % N;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (h[t] != null &amp;&amp; h[t] != x) &#123;</span><br><span class=\"line\">\t\tt++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (t == N) &#123;</span><br><span class=\"line\">\t\t\tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> t;\t<span class=\"comment\">//如果这个位置是空的, 则返回的是他应该存储的位置</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;n);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(h, null, <span class=\"built_in\">sizeof</span>(h));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n --) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> op[<span class=\"number\">2</span>];</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (op[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;I&#x27;</span>) &#123;</span><br><span class=\"line\">\t\t\th[<span class=\"built_in\">find</span>(x)] = x;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (h[<span class=\"built_in\">find</span>(x)] == null) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"字符串哈希表\"><a href=\"#字符串哈希表\" class=\"headerlink\" title=\"字符串哈希表\"></a>字符串哈希表</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230318194927056.png\" alt=\"image-20230318194927056\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">unsigned</span> <span class=\"type\">long</span> <span class=\"type\">long</span> ULL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"type\">const</span> N = <span class=\"number\">10000010</span>, P = <span class=\"number\">131</span>; <span class=\"comment\">//P = 131 或者是 13331 Q一般取 2^64</span></span><br><span class=\"line\"><span class=\"comment\">// P 代表进制 </span></span><br><span class=\"line\"></span><br><span class=\"line\">ULL h[N], p[N];</span><br><span class=\"line\"><span class=\"type\">char</span> a[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ULL <span class=\"title\">query</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> h[r] - h[l - <span class=\"number\">1</span>] * p[r - l + <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> n, m;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%s&quot;</span>, a + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\th[<span class=\"number\">0</span>] = <span class=\"number\">0</span>, p[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) &#123;</span><br><span class=\"line\">\t\th[i] = h[i - <span class=\"number\">1</span>] * P + a[i];</span><br><span class=\"line\">\t\tp[i] = p[i - <span class=\"number\">1</span>] * P;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (m --) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> l1, l2, r1, r2;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d %d %d %d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">query</span>(l1, r1) == <span class=\"built_in\">query</span>(l2, r2))</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes\\n&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230323161436730.png\" alt=\"image-20230323161436730\"></p>\n<h2 id=\"最小根堆\"><a href=\"#最小根堆\" class=\"headerlink\" title=\"最小根堆\"></a>最小根堆</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#icnlude <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">priority_queue&lt;<span class=\"type\">int</span>, vector&lt;<span class=\"type\">int</span>&gt;, greater&lt;<span class=\"type\">int</span>&gt;&gt; heap;</span><br><span class=\"line\">heap.<span class=\"built_in\">push</span>(x), x = heap.<span class=\"built_in\">top</span>(), heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\"><span class=\"comment\">//每次弹出来的顶端都是最小值，并且push后堆会自动排序</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"关于sort-函数\"><a href=\"#关于sort-函数\" class=\"headerlink\" title=\"关于sort()函数\"></a>关于sort()函数</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num[<span class=\"number\">100</span>];</span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> a,<span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b;\t\t\t\t\t\t\t\t <span class=\"comment\">//a&gt;b为由大到小，b&lt;a为由小到大</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sort(num,num+<span class=\"number\">100</span>,cmp);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a, b , w;</span><br><span class=\"line\">&#125;edges[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(Edge a, Edge b)</span></span>&#123;\t\t\t\t\t\t<span class=\"comment\">//按照w的大小排序，此时为递增</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.w &lt; b.w;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">sort</span>(edges, edges + m, cmp);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以自定义排序</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"type\">int</span> x,<span class=\"type\">int</span> y)</span></span>&#123;\t\t\t\t\t<span class=\"comment\">//按照个位数的大小排序，此时为递增</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x % <span class=\"number\">10</span> &lt; y % <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol>\n<li>sort(首地址，尾地址+1，cmp)</li>\n<li>这个函数可以传两个或者三个参数</li>\n<li>第一个参数是要排序的区间首地址</li>\n<li>第二个参数是区间尾地址的下一个地址</li>\n<li>第三个参数不写,则为递增排序</li>\n</ol>\n<h2 id=\"求最大公约数、最小公倍数\"><a href=\"#求最大公约数、最小公倍数\" class=\"headerlink\" title=\"求最大公约数、最小公倍数\"></a>求最大公约数、最小公倍数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;\t<span class=\"comment\">//最大公约数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b ? <span class=\"built_in\">gcd</span>(b, a % b) : a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcb</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span></span>&#123;\t<span class=\"comment\">//最小公倍数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b / <span class=\"built_in\">gcd</span>(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"取模\"><a href=\"#取模\" class=\"headerlink\" title=\"取模\"></a>取模</h2><p>同余定理：x%mod&#x3D;(x+mod)%mod</p>\n<h2 id=\"无穷大\"><a href=\"#无穷大\" class=\"headerlink\" title=\"无穷大\"></a>无穷大</h2><p>inf &#x3D; 0x3f3f3f3f</p>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223240363.png\" alt=\"image-20230406223240363\"></p>\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223251946.png\" alt=\"image-20230406223251946\"></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> a[N], tmp[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l &gt;= r) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = l + r &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">merge_sort</span>(l, mid), <span class=\"built_in\">merge_sort</span>(mid + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"type\">int</span> k = <span class=\"number\">0</span>, i = l, j = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(a[i] &lt;= a[j]) tmp[k ++] = a[i ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> tmp[k ++] = a[j ++];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt;= mid) tmp[k ++] = a[i ++];</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(j &lt;= r) tmp[k ++] = a[j ++];</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = l, j = <span class=\"number\">0</span>; i &lt;= r; i ++, j ++) a[i] = tmp[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h2><p>初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> e[N], ne[N], h[N], w[N], dist[N], idx;</span><br><span class=\"line\"><span class=\"type\">int</span> n, m;</span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">\te[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(h, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> h);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h3><p>朴素版</p>\n<p>题型：稠密图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dist));</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visited[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[j] &lt; dist[t]))</span><br><span class=\"line\">                t = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j++)</span><br><span class=\"line\">            dist[j] = <span class=\"built_in\">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>堆优化</p>\n<p>题型：稀疏图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dijkstra</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"built_in\">sizeof</span>(dist));</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class=\"comment\">// 定义一个小根堆</span></span><br><span class=\"line\">    <span class=\"comment\">// 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，</span></span><br><span class=\"line\">    <span class=\"comment\">// 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。</span></span><br><span class=\"line\">    heap.<span class=\"built_in\">push</span>(&#123; <span class=\"number\">0</span>, <span class=\"number\">1</span> &#125;); <span class=\"comment\">// 这个顺序不能倒，pair排序时是先根据first，再根据second，</span></span><br><span class=\"line\">                         <span class=\"comment\">// 这里显然要根据距离排序</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(heap.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PII k = heap.<span class=\"built_in\">top</span>(); <span class=\"comment\">// 取不在集合S中距离最短的点</span></span><br><span class=\"line\">        heap.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> ver = k.second, distance = k.first;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st[ver]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        st[ver] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = h[ver]; i != <span class=\"number\">-1</span>; i = ne[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j = e[i]; <span class=\"comment\">// i只是个下标，e中在存的是i这个下标对应的点。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[j] &gt; distance + w[i])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dist[j] = distance + w[i];</span><br><span class=\"line\">                heap.<span class=\"built_in\">push</span>(&#123; dist[j], j &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n] == <span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Spfa算法\"><a href=\"#Spfa算法\" class=\"headerlink\" title=\"Spfa算法\"></a>Spfa算法</h3><p>可用于负权图</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dist[j] = dist[t] + w[i] <span class=\"comment\">//当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">spfa</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    queue&lt;PII&gt; q;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist,<span class=\"number\">0x3f</span>,<span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    q.<span class=\"built_in\">push</span>(&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    st[<span class=\"number\">1</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(q.<span class=\"built_in\">size</span>())&#123;</span><br><span class=\"line\">        PII p=q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">        q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> t=p.se;</span><br><span class=\"line\">        st[t]=<span class=\"literal\">false</span>;<span class=\"comment\">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=h[t];i!=<span class=\"number\">-1</span>;i=ne[i])&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> j=e[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class=\"line\">                dist[j]=dist[t]+w[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st[j])&#123;<span class=\"comment\">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class=\"line\">                    st[j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    q.<span class=\"built_in\">push</span>(&#123;dist[j],j&#125;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(dist[n]==<span class=\"number\">0x3f3f3f3f</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tqueue&lt;<span class=\"type\">int</span>&gt; q;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) &#123;<span class=\"comment\">//需要判断的是有无负权回路，则应该是从每个点开始遍历</span></span><br><span class=\"line\">\t\tq.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">\t\tst[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (q.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tq.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">\t\tst[t] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[t]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[j] = dist[t] + w[i];</span><br><span class=\"line\">\t\t\t\tcnt[j] = cnt[t] + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cnt[j] &gt; n)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!st[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tst[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t\tq.<span class=\"built_in\">push</span>(j);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">spfa</span><span class=\"params\">()</span> </span>&#123;\t\t<span class=\"comment\">//从 start 到 ed 的最小权重</span></span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\"></span><br><span class=\"line\">\tdist[start] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tq[<span class=\"number\">0</span>] = start, st[start] = <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (hh != tt) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = q[hh ++];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (hh == N)\t\t</span><br><span class=\"line\">\t\t\thh = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tst[t] = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[t]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class=\"line\">\t\t\t\tdist[j] = dist[t] + w[i];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!st[j]) &#123;</span><br><span class=\"line\">\t\t\t\t\tq[tt ++] = j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> (tt == N)</span><br><span class=\"line\">\t\t\t\t\t\ttt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t\t\tst[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Bellman-ford算法\"><a href=\"#Bellman-ford算法\" class=\"headerlink\" title=\"Bellman_ford算法\"></a>Bellman_ford算法</h3><p>可用于负权回路图。</p>\n<p>1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路</p>\n<p>核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f &#x2F; 2 ，即无法用 k 步走到 n 点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bellman_ford</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">    dist[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) &#123;<span class=\"comment\">//k次循环</span></span><br><span class=\"line\">        <span class=\"built_in\">memcpy</span>(back, dist, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j++) &#123;<span class=\"comment\">//遍历所有边</span></span><br><span class=\"line\">            <span class=\"type\">int</span> a = e[j].a, b = e[j].b, w = e[j].w;</span><br><span class=\"line\">            dist[b] = <span class=\"built_in\">min</span>(dist[b], back[a] + w);</span><br><span class=\"line\">            <span class=\"comment\">//使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dist[n] &gt; <span class=\"number\">0x3f3f3f3f</span> / <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> dist[n];</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>题型：<strong>稠密图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：从 n 个点中选出一个离当前生成树的最小路径，res +&#x3D;该路径，并且用这个点更新其余的点（ dist[ j ] &#x3D; min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] &#x3D; INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Prim</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(dist, <span class=\"number\">0x3f</span>, <span class=\"keyword\">sizeof</span> dist);</span><br><span class=\"line\">\t<span class=\"comment\">//dist[j]： 点j到目前生成树的距离</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> t = <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!st[j] &amp;&amp; (t == <span class=\"number\">-1</span> || dist[j] &lt; dist[t]))</span><br><span class=\"line\">\t\t\t\tt = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i)</span><br><span class=\"line\">\t\t\tres += dist[t];</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= n; j ++) &#123;</span><br><span class=\"line\">\t\t\tdist[j] = <span class=\"built_in\">min</span>(dist[j], g[t][j]);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (i &amp;&amp; dist[t] == INF)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> INF;</span><br><span class=\"line\">\t\tst[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>题型：<strong>稀疏图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res +&#x3D; 边权值，cnt ++。 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(edges, edges + m, cmp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"type\">int</span> res = <span class=\"number\">0</span>, cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ta = <span class=\"built_in\">find</span>(a), b = <span class=\"built_in\">find</span>(b);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a != b) &#123;</span><br><span class=\"line\">\t\t\tres += w;</span><br><span class=\"line\">\t\t\tcnt ++;</span><br><span class=\"line\">\t\t\tp[a] = b;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (cnt &lt; n - <span class=\"number\">1</span>)<span class=\"comment\">//边数小于 n - 1 说明有孤立点 </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;impossible&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>, res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"染色法判定二分图\"><a href=\"#染色法判定二分图\" class=\"headerlink\" title=\"染色法判定二分图\"></a>染色法判定二分图</h3><p>题型：判断二分图</p>\n<p>思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">    color[u] = c;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[u]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!color[j]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">DFS</span>(j, <span class=\"number\">3</span> - c))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (color[j] == c)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!color[i]) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!<span class=\"built_in\">DFS</span>(i, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tflag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Yes&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;No&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h3><p>题型：邻接表，求二分图的最大匹配</p>\n<p>思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配），</p>\n<p>如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] &#x3D; x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;\t\t\t<span class=\"comment\">//帮助男生 x 匹配女生，成功返回true，否则返回false</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[x]; i != <span class=\"number\">-1</span>; i = ne[i]) &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!st[j]) &#123;</span><br><span class=\"line\">\t\t\tst[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (match[j] == <span class=\"number\">0</span> || <span class=\"built_in\">find</span>(match[j])) &#123;</span><br><span class=\"line\">\t\t\t\tmatch[j] = x;\t\t<span class=\"comment\">//match[j]代表 女生 j 的匹配的男生为 match[j]</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n1; i ++) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(st, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span> st);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"built_in\">find</span>(i))</span><br><span class=\"line\">\t\t\tres ++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数位Dp\"><a href=\"#数位Dp\" class=\"headerlink\" title=\"数位Dp\"></a>数位Dp</h2><p>把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">dp</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; nums;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n) nums.<span class=\"built_in\">push_back</span>(n % B), n /= B;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">0</span>, last = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i -- )&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> x = nums[i];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"树的最长路径\"><a href=\"#树的最长路径\" class=\"headerlink\" title=\"树的最长路径\"></a>树的最长路径</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> u, <span class=\"type\">int</span> father)</span><span class=\"comment\">//防止从下往上遍历，引入 father</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    f1[u] = f2[u] = <span class=\"number\">0</span>;<span class=\"comment\">//从 u 点出发， f1 为最长的路径， f2 为第二长的路径</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> j = e[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == father) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(j, u);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (f1[j] + w[i] &gt;= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; <span class=\"comment\">//最长路转移</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f1[j] + w[i] &gt; f2[u]) f2[u] = f1[j] + w[i];            <span class=\"comment\">//次长路转移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res = <span class=\"built_in\">max</span>(res, f1[u] + f2[u]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Flood-Fill\"><a href=\"#Flood-Fill\" class=\"headerlink\" title=\"Flood Fill\"></a>Flood Fill</h2><p>求连通块的数量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy)</span></span>&#123;</span><br><span class=\"line\">    st[sx][sy] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    q[<span class=\"number\">0</span>] = &#123;sx, sy&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(hh &lt;= tt)&#123;</span><br><span class=\"line\">        PII t = q[hh ++];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = t.x - <span class=\"number\">1</span>; i &lt;= t.x + <span class=\"number\">1</span>; i ++ )</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = t.y - <span class=\"number\">1</span>; j &lt;= t.y + <span class=\"number\">1</span>; j ++ )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == t.x &amp;&amp; j == t.y) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (g[i][j] == <span class=\"string\">&#x27;.&#x27;</span> || st[i][j]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= n || j &lt; <span class=\"number\">0</span> || j &gt;= m) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                q[ ++ tt] = &#123;i, j&#125;;</span><br><span class=\"line\">                st[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j ++ )&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[i][j] == <span class=\"string\">&#x27;W&#x27;</span> &amp;&amp; !st[i][j])&#123; <span class=\"comment\">//需要联通的条件，并且该点没有遍历</span></span><br><span class=\"line\">                <span class=\"built_in\">bfs</span>(i, j);</span><br><span class=\"line\">                cnt ++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;\t<span class=\"comment\">//求最短路径</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(dist, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> dist);<span class=\"comment\">//定义所有点都没有遍历</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> sx, sy;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; m; j ++ )</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[i][j] == <span class=\"string\">&#x27;K&#x27;</span>)&#123;</span><br><span class=\"line\">                sx = i, sy = j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q[<span class=\"number\">0</span>] = &#123;sx, sy&#125;;</span><br><span class=\"line\">    dist[sx][sy] = <span class=\"number\">0</span>;<span class=\"comment\">//起始点的距离为0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(hh &lt;= tt)&#123;</span><br><span class=\"line\">        PII t = q[hh ++ ];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">8</span>; i ++ )&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = t.x + dx[i], b = t.y + dy[i];<span class=\"comment\">//枚举下一个点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span> || a &gt;= n || b &lt; <span class=\"number\">0</span> || b &gt;= m) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[a][b] == <span class=\"string\">&#x27;*&#x27;</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dist[a][b] != <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//表示下一个点有没有遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[a][b] == <span class=\"string\">&#x27;H&#x27;</span>) <span class=\"keyword\">return</span> dist[t.x][t.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            dist[a][b] = dist[t.x][t.y] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            q[ ++ tt] = &#123;a, b&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bfs</span><span class=\"params\">(<span class=\"type\">int</span> sx, <span class=\"type\">int</span> sy)</span></span>&#123;<span class=\"comment\">//求最短路径，并且输出路径</span></span><br><span class=\"line\">    <span class=\"type\">int</span> dx[] = &#123;<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, dy[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> hh = <span class=\"number\">0</span>, tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    q[<span class=\"number\">0</span>] = &#123;sx, sy&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(pre, <span class=\"number\">-1</span>, <span class=\"keyword\">sizeof</span> pre);<span class=\"comment\">//pre 用于存储路径</span></span><br><span class=\"line\">    pre[sx][sy] = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (hh &lt;= tt)&#123;</span><br><span class=\"line\">        PII t = q[hh ++ ];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i ++ )&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a &lt; <span class=\"number\">0</span> || a &gt;= n || b &lt; <span class=\"number\">0</span> || b &gt;= n) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (g[a][b]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pre[a][b].x != <span class=\"number\">-1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            q[ ++ tt] = &#123;a, b&#125;;</span><br><span class=\"line\">            pre[a][b] = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h2><h3 id=\"线性筛法求素数\"><a href=\"#线性筛法求素数\" class=\"headerlink\" title=\"线性筛法求素数\"></a>线性筛法求素数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> primes[N], cnt;     <span class=\"comment\">// primes[]存储所有素数</span></span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];         <span class=\"comment\">// st[x]存储x是否被筛掉</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_primes</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            st[primes[j] * i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % primes[j] == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">gcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span><span class=\"comment\">//求最大公约数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b ? <span class=\"built_in\">gcd</span>(b, a % b) : a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"试除法求所有约数\"><a href=\"#试除法求所有约数\" class=\"headerlink\" title=\"试除法求所有约数\"></a>试除法求所有约数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">get_divisors</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= x / i; i ++ )</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x % i == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != x / i) res.<span class=\"built_in\">push_back</span>(x / i);<span class=\"comment\">//防止相同的数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"built_in\">sort</span>(res.<span class=\"built_in\">begin</span>(), res.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"筛法求欧拉函数\"><a href=\"#筛法求欧拉函数\" class=\"headerlink\" title=\"筛法求欧拉函数\"></a>筛法求欧拉函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> primes[N], cnt;     <span class=\"comment\">// primes[]存储所有素数</span></span><br><span class=\"line\"><span class=\"type\">int</span> euler[N];           <span class=\"comment\">// 存储每个数的欧拉函数</span></span><br><span class=\"line\"><span class=\"type\">bool</span> st[N];         <span class=\"comment\">// st[x]存储x是否被筛掉</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get_eulers</span><span class=\"params\">(<span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    euler[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= n; i ++ )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st[i])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            primes[cnt ++ ] = i;</span><br><span class=\"line\">            euler[i] = i - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> t = primes[j] * i;</span><br><span class=\"line\">            st[t] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i % primes[j] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                euler[t] = euler[i] * primes[j];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            euler[t] = euler[i] * (primes[j] - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">qmi</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> k, <span class=\"type\">int</span> p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> res = <span class=\"number\">1</span> % p, t = m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &amp; <span class=\"number\">1</span>) res = res * t % p;</span><br><span class=\"line\">        t = t * t % p;</span><br><span class=\"line\">        k &gt;&gt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a>扩展欧几里得算法</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">exgcd</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b, <span class=\"type\">int</span> &amp;x, <span class=\"type\">int</span> &amp;y)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!b)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        x = <span class=\"number\">1</span>; y = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> d = <span class=\"built_in\">exgcd</span>(b, a % b, y, x);</span><br><span class=\"line\">    y -= (a/b) * x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","path":"2023/12/16/算法笔记/","permalink":"http://example.com/2023/12/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","tags":[{"name":"算法","_id":"clq9fmlcl000l4otf9x3h8cmy","slug":"算法","path":"tags/算法/","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/","length":1}],"categories":[],"prev":null,"next":{"title":"用ChatGPT做PPT","date":"2023-12-10T04:37:03.000Z","summary":"快速制作一份简单的PPT","slug":"用ChatGPT做PPT","published":true,"updated":"2023-12-14T14:15:18.128Z","_id":"clq9fmlch00094otfh26365yy","layout":"post","photos":[],"link":"","excerpt":"","path":"2023/12/10/用ChatGPT做PPT/","permalink":"http://example.com/2023/12/10/%E7%94%A8ChatGPT%E5%81%9APPT/","__post":true},"__post":true}