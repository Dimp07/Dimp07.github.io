{"title":"算法笔记","date":"2023-12-16T13:22:15.000Z","toc":null,"summary":null,"source":"_posts/算法笔记.md","raw":"---\ntitle: 算法笔记\ndate: 2023-12-16 21:22:15\ntags: 算法\ntoc:\nsummary:\ncopyright:\nauthor:\n---\n\n## C++头文件\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <unordered_map>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> PII\n\nvector<int> alls;\n```\n\n\n\n## string 的函数\n\n```c++\nint main(){\n    string a;\n    a.substr(0, k) //从 a[0] 开始到 a[k] ，返回这段字符串\n    a.substr(1)  //从 a[1] 开始到末尾，返回这段字符串\n}\n```\n\n\n\n## 排列组合\n\n![image-20221215192125061](../image/算法笔记/image-20221215192125061.png)![image-20221215192152255](../image/算法笔记/image-20221215192152255.png)\n\n```c++\n//从m个数里抽出n个数，进行全排列\nint arrange(int m,int n){\n    if(m==n)return n;\n    return m*arrange(m-1,n);\n}\n\n//从m个数里抽出n个数，进行组合排序\n//法一\nint cnm(int n,int m){\n    if(n==1)return m;\n    return m*cnm(n-1,m-1)/n;\n}\n//法二\nint cnm(int n,int m){\n    if(n==1)return m;\n    if(n==m)return 1;\n    return (cnm(n,m-1)+cnm(n-1,m-1));\n}\n\n//法三  从 i 个数里抽出 j 个数的方案数\nvoid init(){\n    for (int i = 0; i < N; i ++ )\n        for (int j = 0; j <= i; j ++ ){\n            if (!j) f[i][j] = 1;\n            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n        }\n}\n```\n\n## 二位前缀和\n\n![image-20230314194756707](../image/算法笔记/image-20230314194756707.png)\n\n## 差分\n\n在数组a[l,r]区间内加上c，则可表示为a[l]+=c,a[r+1]+=-c\n\n## 位运算\n\nx>>1，代表x右移一位，值变成1/2；x<<1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。\n\nx >> k & 1 , 代表 x 的第 k 位是否为 1.\n\n```c\nint lowbit(int x){\t\t\t//返回最后一个1的位数\n    return x&-x;\t\t\t/*例如 10 的二进制为 1010，则返回 10*/\n}\n```\n\n## 离散化\n\n```c++\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nvector<int> alls;//储存所有待离散化的值\nsort(alls.begin(),alls.end());//将所有的值排序\nalls.erase(unique(alls.begin(),alls,end),alls.end);//去掉重复元素\n\n//二分法求出x对应的离散化的值\nint find(int x){\n    int l = 0, r = alls.size() - 1;\n    while(l < r){\n        int mid = l + r;\n        if(alls[mid] >= x){\n            r = mid;\n        }\n        else{\n            l = mid +1;\n        }\n    }\n    return r + 1;//返回 1，2，3，4……\n}\n```\n\n## KMP\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; //N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; //next[]数组，避免和头文件next冲突\nchar s[N], p[M];  //s为模式串， p为匹配串\n\nint main()\n{\n    cin >> n >> s+1 >> m >> p+1;  //下标从1开始\n\n    //求next[]数组\n    for(int i = 2, j = 0; i <= m; i++)\n    {\n        while(j && p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    }\n    //匹配操作\n    for(int i = 1, j = 0; i <= n; i++)\n    {\n        while(j && s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  //满足匹配条件，打印开头下标, 从0开始\n        {\n            //匹配完成后的具体操作\n            //如：输出以0开始的匹配子串的首字母下标\n            //printf(\"%d \", i - m); (若从1开始，加1)\n            j = ne[j];            //再次继续匹配\n        }\n    }\n\n    return 0;\n}\n```\n\n\n\n## Trie树\n\n![image-20230317125934107](../image/算法笔记/image-20230317125934107.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(char str[]) {\n\tint p = 0;\n\tfor (int i = 0; str[i]; i++) {\n\t\tint u = str[i] - 'a';\n\t\tif (son[p][u] == 0)\n\t\t\tson[p][u] = ++idx;\n\t\tp = son[p][u];\n\t}\n\tcnt[p]++;\n}\n\nint query(char str[]) {\n\tint p = 0;\n\tfor (int i = 0; str[i]; i++) {\n\t\tint u = str[i] - 'a';\n\t\tif (son[p][u] == 0)\n\t\t\treturn 0;\n\t\tp = son[p][u];\n\t}\n\treturn cnt[p];\n}\n```\n\n## 并查集\n\n```c++\nint find(int x)//返回x的祖宗节点，并压缩路径\n{\n\tif(p[x] != x)p[x] = find(p[x]);\n\treturn p[x];\n}\n\n// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]\n\n//如果要合并两个节点，则\nvoid merge(int a,int b){\n    //if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步\n    size[find(b)] += size[find(a)];  //必须先加size，再合并（a,b）\n    p[find(a)] = find(b);\n    //加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义\n    //如果先合并再相加，则代表两个相同的集合数量相加\n}\n```\n\n## 哈希表\n\n```c++\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了\nconst int N = 2e5 + 3;\t\t\t\t//大于数据范围的第一个质数\nconst int null = 0x3f3f3f3f;\t\t//规定空指针为 null 0x3f3f3f3f\n\nint h[N];\n\nint find(int x) {\n\tint t = (x % N + N) % N;\n\twhile (h[t] != null && h[t] != x) {\n\t\tt++;\n\t\tif (t == N) {\n\t\t\tt = 0;\n\t\t}\n\t}\n\treturn t;\t//如果这个位置是空的, 则返回的是他应该存储的位置\n}\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tmemset(h, null, sizeof(h));\n\n\twhile (n --) {\n\t\tchar op[2];\n\t\tint x;\n\t\tscanf(\"%s%d\", op, &x);\n\t\tif (op[0] == 'I') {\n\t\t\th[find(x)] = x;\n\t\t} else {\n\t\t\tif (h[find(x)] == null) {\n\t\t\t\tprintf(\"No\");\n\t\t\t} else {\n\t\t\t\tprintf(\"Yes\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## 字符串哈希表\n\n![image-20230318194927056](../image/算法笔记/image-20230318194927056.png)\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nint const N = 10000010, P = 131; //P = 131 或者是 13331 Q一般取 2^64\n// P 代表进制 \n\nULL h[N], p[N];\nchar a[N];\n\nULL query(int l, int r) {\n\treturn h[r] - h[l - 1] * p[r - l + 1];\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tscanf(\"%s\", a + 1);\n\n\th[0] = 0, p[0] = 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\th[i] = h[i - 1] * P + a[i];\n\t\tp[i] = p[i - 1] * P;\n\t}\n\n\twhile (m --) {\n\t\tint l1, l2, r1, r2;\n\t\tscanf(\"%d %d %d %d\", &l1, &r1, &l2, &r2);\n\t\tif (query(l1, r1) == query(l2, r2))\n\t\t\tprintf(\"Yes\\n\");\n\t\telse\n\t\t\tprintf(\"No\\n\");\n\t}\n\treturn 0;\n}\n```\n\n![image-20230323161436730](../image/算法笔记/image-20230323161436730.png)\n\n## 最小根堆\n\n```c++\n#include <iostream>\n#include <queue>\n#icnlude <vector>\n\npriority_queue<int, vector<int>, greater<int>> heap;\nheap.push(x), x = heap.top(), heap.pop();\n//每次弹出来的顶端都是最小值，并且push后堆会自动排序\n```\n\n## 关于sort()函数\n\n```c\nint num[100];\nbool cmp(int a,int b){\n    return a > b;\t\t\t\t\t\t\t\t //a>b为由大到小，b<a为由小到大\n}\nsort(num,num+100,cmp);\n\n```\n\n```c++\nstruct Edge{\n    int a, b , w;\n}edges[N];\n\nbool cmp(Edge a, Edge b){\t\t\t\t\t\t//按照w的大小排序，此时为递增\n    return a.w < b.w;\n}\n\nsort(edges, edges + m, cmp);\n```\n\n```c++\n//可以自定义排序\nbool cmp(int x,int y){\t\t\t\t\t//按照个位数的大小排序，此时为递增\n\treturn x % 10 < y % 10;\n}\n```\n\n\n\n1. sort(首地址，尾地址+1，cmp)\n2. 这个函数可以传两个或者三个参数\n3. 第一个参数是要排序的区间首地址\n4. 第二个参数是区间尾地址的下一个地址\n5. 第三个参数不写,则为递增排序\n\n## 求最大公约数、最小公倍数\n\n```c++\nint gcd(int a, int b){\t//最大公约数\n    return b ? gcd(b, a % b) : a;\n}\n\nint gcb(int a, int b){\t//最小公倍数\n    return a * b / gcd(a, b);\n}\n```\n\n## 取模\n\n同余定理：x%mod=(x+mod)%mod\n\n## 无穷大\n\ninf = 0x3f3f3f3f\n\n## 二分\n\n![image-20230406223240363](../image/算法笔记/image-20230406223240363.png)\n\n![image-20230406223251946](../image/算法笔记/image-20230406223251946.png)\n\n## 归并排序\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint a[N], tmp[N];\n\nvoid merge_sort(int l, int r){\n\tif(l >= r) return ;\n\t\n\tint mid = l + r >> 1;\n\tmerge_sort(l, mid), merge_sort(mid + 1, r);\n\t\n\tint k = 0, i = l, j = mid + 1;\n\twhile(i <= mid && j <= r){\n\t\tif(a[i] <= a[j]) tmp[k ++] = a[i ++];\n\t\telse tmp[k ++] = a[j ++];\n\t}\n\t\n\twhile(i <= mid) tmp[k ++] = a[i ++];\n\twhile(j <= r) tmp[k ++] = a[j ++];\n\t\n\tfor (int i = l, j = 0; i <= r; i ++, j ++) a[i] = tmp[j];\n}\n```\n\n## 图论\n\n初始化\n\n```c++\nint e[N], ne[N], h[N], w[N], dist[N], idx;\nint n, m;\nbool st[N];\n\nvoid add(int a, int b, int c) {\n\te[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n}\n\nint main(){\n    scanf(\"%d%d\", &n, &m);\n\tmemset(h, -1, sizeof h);\n}\n```\n\n\n\n### Dijkstra算法\n\n朴素版\n\n题型：稠密图\n\n思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边\n\n```c++\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        int t = -1;\n        for(int j = 1; j <= n; j++)\n        {\n            if(!visited[j] && (t == -1 || dist[j] < dist[t]))\n                t = j;\n        }\n        visited[t] = true;\n        for(int j = 1; j <= n; j++)\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n    }\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n```\n\n堆优化\n\n题型：稀疏图\n\n思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边\n\n```c++\nint dijkstra()\n{\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    priority_queue<PII, vector<PII>, greater<PII>> heap; // 定义一个小根堆\n    // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，\n    // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。\n    heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，\n                         // 这里显然要根据距离排序\n    while(heap.size())\n    {\n        PII k = heap.top(); // 取不在集合S中距离最短的点\n        heap.pop();\n        int ver = k.second, distance = k.first;\n\n        if(st[ver]) continue;\n        st[ver] = true;\n\n        for(int i = h[ver]; i != -1; i = ne[i])\n        {\n            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。\n            if(dist[j] > distance + w[i])\n            {\n                dist[j] = distance + w[i];\n                heap.push({ dist[j], j });\n            }\n        }\n    }\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    else return dist[n];\n}\n```\n\n\n\n### Spfa算法\n\n可用于负权图\n\n```c++\ndist[j] = dist[t] + w[i] //当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边\n```\n\n\n\n```c++\nint spfa(){\n    queue<PII> q;\n    memset(dist,0x3f,sizeof dist);\n    dist[1]=0;\n    q.push({0,1});\n    st[1]=true;\n    while(q.size()){\n        PII p=q.front();\n        q.pop();\n        int t=p.se;\n        st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队\n        for(int i=h[t];i!=-1;i=ne[i]){\n            int j=e[i];\n            if(dist[j]>dist[t]+w[i]){\n                dist[j]=dist[t]+w[i];\n                if(!st[j]){//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率\n                    st[j]=true;\n                    q.push({dist[j],j});\n                }\n            }\n        }\n    }\n    if(dist[n]==0x3f3f3f3f) return -1;\n    else return dist[n];\n}\n```\n\n\n\n如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。\n\n```c++\nbool spfa() {\n\tqueue<int> q;\n\n\tfor (int i = 1; i <= n; i ++) {//需要判断的是有无负权回路，则应该是从每个点开始遍历\n\t\tq.push(i);\n\t\tst[i] = true;\n\t}\n\n\twhile (q.size()) {\n\t\tint t = q.front();\n\n\t\tq.pop();\n\t\tst[t] = false;\n\n\t\tfor (int i = h[t]; i != -1; i = ne[i]) {\n\t\t\tint j = e[i];\n\t\t\tif (dist[j] > dist[t] + w[i]) {\n\t\t\t\tdist[j] = dist[t] + w[i];\n\t\t\t\tcnt[j] = cnt[t] + 1;\n\t\t\t\tif (cnt[j] > n)\n\t\t\t\t\treturn true;\n\t\t\t\tif (!st[j]) {\n\t\t\t\t\tst[j] = true;\n\t\t\t\t\tq.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n\n\n```c++\nvoid spfa() {\t\t//从 start 到 ed 的最小权重\n\tmemset(dist, 0x3f, sizeof dist);\n\n\tdist[start] = 0;\n\n\tq[0] = start, st[start] = true;\n\n\tint hh = 0, tt = 1;\n\twhile (hh != tt) {\n\t\tint t = q[hh ++];\n\t\tif (hh == N)\t\t\n\t\t\thh = 0;\n\t\tst[t] = false;\n\n\t\tfor (int i = h[t]; i != -1; i = ne[i]) {\n\t\t\tint j = e[i];\n\t\t\tif (dist[j] > dist[t] + w[i]) {\n\t\t\t\tdist[j] = dist[t] + w[i];\n\t\t\t\tif (!st[j]) {\n\t\t\t\t\tq[tt ++] = j;\n\t\t\t\t\tif (tt == N)\n\t\t\t\t\t\ttt = 0;\n\t\t\t\t\tst[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\n\n### Bellman_ford算法\n\n可用于负权回路图。\n\n1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路\n\n核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f / 2 ，即无法用 k 步走到 n 点\n\n```c++\nint bellman_ford() {\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i < k; i++) {//k次循环\n        memcpy(back, dist, sizeof dist);\n        for (int j = 0; j < m; j++) {//遍历所有边\n            int a = e[j].a, b = e[j].b, w = e[j].w;\n            dist[b] = min(dist[b], back[a] + w);\n            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来\n        }\n    }\n    if (dist[n] > 0x3f3f3f3f / 2) return -1;\n    else return dist[n];\n\n}\n```\n\n### Prim算法\n\n题型：**稠密图**，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）\n\n思想：从 n 个点中选出一个离当前生成树的最小路径，res +=该路径，并且用这个点更新其余的点（ dist[ j ] = min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] = INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。\n\n```c++\nint Prim() {\n\tmemset(dist, 0x3f, sizeof dist);\n\t//dist[j]： 点j到目前生成树的距离\n\tint res = 0;\n\tfor (int i = 0; i < n; i ++) {\n\t\tint t = -1;\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tif (!st[j] && (t == -1 || dist[j] < dist[t]))\n\t\t\t\tt = j;\n\t\t}\n\n\t\tif (i)\n\t\t\tres += dist[t];\n\n\t\tfor (int j = 1; j <= n; j ++) {\n\t\t\tdist[j] = min(dist[j], g[t][j]);\n\t\t}\n\n\t\tif (i && dist[t] == INF)\n\t\t\treturn INF;\n\t\tst[t] = true;\n\t}\n\treturn res;\n}\n```\n\n### Kruskal算法\n\n题型：**稀疏图**，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）\n\n思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res += 边权值，cnt ++。 \n\n```c++\nint main(){\nsort(edges, edges + m, cmp);\n\n\tint res = 0, cnt = 0;\n\tfor (int i = 0; i < m; i ++) {\n\t\tint a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n\t\ta = find(a), b = find(b);\n\t\tif (a != b) {\n\t\t\tres += w;\n\t\t\tcnt ++;\n\t\t\tp[a] = b;\n\t\t}\n\t}\n\n\tif (cnt < n - 1)//边数小于 n - 1 说明有孤立点 \n\t\tprintf(\"impossible\");\n\telse\n\t\tprintf(\"%d\", res);\n}\n```\n\n### 染色法判定二分图\n\n题型：判断二分图\n\n思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图\n\n```c++\nbool DFS(int u, int c) {\n    color[u] = c;\n\tfor (int i = h[u]; i != -1; i = ne[i]) {\n\t\tint j = e[i];\n\t\tif (!color[j]) {\n\t\t\tif (!DFS(j, 3 - c))\n\t\t\t\treturn false;\n\t\t} else if (color[j] == c)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n    bool flag = true;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (!color[i]) {\n\t\t\tif (!DFS(i, 1)) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flag)\n\t\tprintf(\"Yes\");\n\telse\n\t\tprintf(\"No\");\n}\n```\n\n### 匈牙利算法\n\n题型：邻接表，求二分图的最大匹配\n\n思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配），\n\n如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] = x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。\n\n```c++\nbool find(int x) {\t\t\t//帮助男生 x 匹配女生，成功返回true，否则返回false\n\tfor (int i = h[x]; i != -1; i = ne[i]) {\n\t\tint j = e[i];\n\t\tif (!st[j]) {\n\t\t\tst[j] = true;\n\t\t\tif (match[j] == 0 || find(match[j])) {\n\t\t\t\tmatch[j] = x;\t\t//match[j]代表 女生 j 的匹配的男生为 match[j]\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n    for (int i = 1; i <= n1; i ++) {\n\t\tmemset(st, false, sizeof st);\n\t\tif (find(i))\n\t\t\tres ++;\n\t}\n}\n```\n\n## 数位Dp\n\n把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算\n\n```c++\nint dp(int n){\n    if (n == 0) return 0;\n\n    vector<int> nums;\n    while(n) nums.push_back(n % B), n /= B;\n\n    int res = 0, last = 0;\n    for (int i = nums.size() - 1; i >= 0; i -- ){\n        int x = nums[i];\n\n    }\n    return res;\n}\n```\n\n## 树的最长路径\n\n```c++\nvoid dfs(int u, int father)//防止从下往上遍历，引入 father\n{\n    f1[u] = f2[u] = 0;//从 u 点出发， f1 为最长的路径， f2 为第二长的路径\n    for (int i = h[u]; ~i; i = ne[i])\n    {\n        int j = e[i];\n        if (j == father) continue;\n        dfs(j, u);\n        if (f1[j] + w[i] >= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; //最长路转移\n        else if (f1[j] + w[i] > f2[u]) f2[u] = f1[j] + w[i];            //次长路转移\n    }\n    res = max(res, f1[u] + f2[u]);\n}\n```\n\n## Flood Fill\n\n求连通块的数量\n\n```c++\nvoid bfs(int sx, int sy){\n    st[sx][sy] = true;\n    q[0] = {sx, sy};\n\n    int hh = 0, tt = 0;\n    while(hh <= tt){\n        PII t = q[hh ++];\n        for (int i = t.x - 1; i <= t.x + 1; i ++ )\n            for (int j = t.y - 1; j <= t.y + 1; j ++ ){\n                if (i == t.x && j == t.y) continue;\n                if (g[i][j] == '.' || st[i][j]) continue;\n                if (i < 0 || i >= n || j < 0 || j >= m) continue;\n                q[ ++ tt] = {i, j};\n                st[i][j] = true;\n            }\n    }\n}\n\nint cnt = 0;\n    for (int i = 0; i < n; i ++ )\n        for (int j = 0; j < m; j ++ ){\n            if (g[i][j] == 'W' && !st[i][j]){ //需要联通的条件，并且该点没有遍历\n                bfs(i, j);\n                cnt ++;\n            }\n        }\n```\n\n```c++\nint bfs(){\t//求最短路径\n    memset(dist, -1, sizeof dist);//定义所有点都没有遍历\n    \n    int sx, sy;\n    for (int i = 0; i < n; i ++ )\n        for (int j = 0; j < m; j ++ )\n            if (g[i][j] == 'K'){\n                sx = i, sy = j;\n            }\n    \n    int hh = 0, tt = 0;\n    q[0] = {sx, sy};\n    dist[sx][sy] = 0;//起始点的距离为0\n    while(hh <= tt){\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i < 8; i ++ ){\n            int a = t.x + dx[i], b = t.y + dy[i];//枚举下一个点\n            if (a < 0 || a >= n || b < 0 || b >= m) continue;\n            if (g[a][b] == '*') continue;\n            if (dist[a][b] != -1) continue;//表示下一个点有没有遍历\n            if (g[a][b] == 'H') return dist[t.x][t.y] + 1;\n\n            dist[a][b] = dist[t.x][t.y] + 1;\n            q[ ++ tt] = {a, b};\n        }\n    }\n}\n```\n\n```c++\nvoid bfs(int sx, int sy){//求最短路径，并且输出路径\n    int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\n    int hh = 0, tt = 0;\n    q[0] = {sx, sy};\n\n    memset(pre, -1, sizeof pre);//pre 用于存储路径\n    pre[sx][sy] = {0, 0};\n//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的\n    while (hh <= tt){\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i < 4; i ++ ){\n            int a = t.x + dx[i], b = t.y + dy[i];\n            if (a < 0 || a >= n || b < 0 || b >= n) continue;\n            if (g[a][b]) continue;\n            if (pre[a][b].x != -1) continue;\n\n            q[ ++ tt] = {a, b};\n            pre[a][b] = t;\n        }\n    }\n}\n```\n\n## 数学知识\n\n### 线性筛法求素数 \n\n```c++\nint primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n{\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        }\n    }\n}\n```\n\n### 欧几里得算法\n\n```c++\nint gcd(int a, int b)//求最大公约数\n{\n    return b ? gcd(b, a % b) : a;\n}\n```\n\n### 试除法求所有约数\n\n```c++\nvector<int> get_divisors(int x)\n{\n    vector<int> res;\n    for (int i = 1; i <= x / i; i ++ )\n        if (x % i == 0)\n        {\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);//防止相同的数\n        }\n    sort(res.begin(), res.end());\n    return res;\n}\n```\n\n### 筛法求欧拉函数\n\n```c++\nint primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n{\n    euler[1] = 1;\n    for (int i = 2; i <= n; i ++ )\n    {\n        if (!st[i])\n        {\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        }\n        for (int j = 0; primes[j] <= n / i; j ++ )\n        {\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            {\n                euler[t] = euler[i] * primes[j];\n                break;\n            }\n            euler[t] = euler[i] * (primes[j] - 1);\n        }\n    }\n}\n```\n\n### 快速幂\n\n```c++\nint qmi(int m, int k, int p)\n{\n    int res = 1 % p, t = m;\n    while (k)\n    {\n        if (k & 1) res = res * t % p;\n        t = t * t % p;\n        k >>= 1;\n    }\n    return res;\n}\n```\n\n### 扩展欧几里得算法\n\n```c++\n// 求x, y，使得ax + by = gcd(a, b)\nint exgcd(int a, int b, int &x, int &y)\n{\n    if (!b)\n    {\n        x = 1; y = 0;\n        return a;\n    }\n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;\n    return d;\n}\n```\n\n","slug":"算法笔记","published":true,"updated":"2023-12-16T13:25:14.243Z","_id":"clq83chp600005ctfd9q4eypn","comments":true,"layout":"post","photos":[],"link":"","html":"<h2 id=\"C-头文件\"><a href=\"#C-头文件\" class=\"headerlink\" title=\"C++头文件\"></a>C++头文件</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_map&gt;\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII\n\nvector&lt;int&gt; alls;\n</code></pre>\n<h2 id=\"string-的函数\"><a href=\"#string-的函数\" class=\"headerlink\" title=\"string 的函数\"></a>string 的函数</h2><pre><code class=\"c++\">int main()&#123;\n    string a;\n    a.substr(0, k) //从 a[0] 开始到 a[k] ，返回这段字符串\n    a.substr(1)  //从 a[1] 开始到末尾，返回这段字符串\n&#125;\n</code></pre>\n<h2 id=\"排列组合\"><a href=\"#排列组合\" class=\"headerlink\" title=\"排列组合\"></a>排列组合</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192125061.png\" alt=\"image-20221215192125061\"><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192152255.png\" alt=\"image-20221215192152255\"></p>\n<pre><code class=\"c++\">//从m个数里抽出n个数，进行全排列\nint arrange(int m,int n)&#123;\n    if(m==n)return n;\n    return m*arrange(m-1,n);\n&#125;\n\n//从m个数里抽出n个数，进行组合排序\n//法一\nint cnm(int n,int m)&#123;\n    if(n==1)return m;\n    return m*cnm(n-1,m-1)/n;\n&#125;\n//法二\nint cnm(int n,int m)&#123;\n    if(n==1)return m;\n    if(n==m)return 1;\n    return (cnm(n,m-1)+cnm(n-1,m-1));\n&#125;\n\n//法三  从 i 个数里抽出 j 个数的方案数\nvoid init()&#123;\n    for (int i = 0; i &lt; N; i ++ )\n        for (int j = 0; j &lt;= i; j ++ )&#123;\n            if (!j) f[i][j] = 1;\n            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n        &#125;\n&#125;\n</code></pre>\n<h2 id=\"二位前缀和\"><a href=\"#二位前缀和\" class=\"headerlink\" title=\"二位前缀和\"></a>二位前缀和</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230314194756707.png\" alt=\"image-20230314194756707\"></p>\n<h2 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h2><p>在数组a[l,r]区间内加上c，则可表示为a[l]+&#x3D;c,a[r+1]+&#x3D;-c</p>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>x&gt;&gt;1，代表x右移一位，值变成1&#x2F;2；x&lt;&lt;1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。</p>\n<p>x &gt;&gt; k &amp; 1 , 代表 x 的第 k 位是否为 1.</p>\n<pre><code class=\"c\">int lowbit(int x)&#123;\t\t\t//返回最后一个1的位数\n    return x&amp;-x;\t\t\t/*例如 10 的二进制为 1010，则返回 10*/\n&#125;\n</code></pre>\n<h2 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h2><pre><code class=\"c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; alls;//储存所有待离散化的值\nsort(alls.begin(),alls.end());//将所有的值排序\nalls.erase(unique(alls.begin(),alls,end),alls.end);//去掉重复元素\n\n//二分法求出x对应的离散化的值\nint find(int x)&#123;\n    int l = 0, r = alls.size() - 1;\n    while(l &lt; r)&#123;\n        int mid = l + r;\n        if(alls[mid] &gt;= x)&#123;\n            r = mid;\n        &#125;\n        else&#123;\n            l = mid +1;\n        &#125;\n    &#125;\n    return r + 1;//返回 1，2，3，4……\n&#125;\n</code></pre>\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; //N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; //next[]数组，避免和头文件next冲突\nchar s[N], p[M];  //s为模式串， p为匹配串\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; s+1 &gt;&gt; m &gt;&gt; p+1;  //下标从1开始\n\n    //求next[]数组\n    for(int i = 2, j = 0; i &lt;= m; i++)\n    &#123;\n        while(j &amp;&amp; p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    &#125;\n    //匹配操作\n    for(int i = 1, j = 0; i &lt;= n; i++)\n    &#123;\n        while(j &amp;&amp; s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  //满足匹配条件，打印开头下标, 从0开始\n        &#123;\n            //匹配完成后的具体操作\n            //如：输出以0开始的匹配子串的首字母下标\n            //printf(&quot;%d &quot;, i - m); (若从1开始，加1)\n            j = ne[j];            //再次继续匹配\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230317125934107.png\" alt=\"image-20230317125934107\"></p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(char str[]) &#123;\n    int p = 0;\n    for (int i = 0; str[i]; i++) &#123;\n        int u = str[i] - &#39;a&#39;;\n        if (son[p][u] == 0)\n            son[p][u] = ++idx;\n        p = son[p][u];\n    &#125;\n    cnt[p]++;\n&#125;\n\nint query(char str[]) &#123;\n    int p = 0;\n    for (int i = 0; str[i]; i++) &#123;\n        int u = str[i] - &#39;a&#39;;\n        if (son[p][u] == 0)\n            return 0;\n        p = son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n</code></pre>\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><pre><code class=\"c++\">int find(int x)//返回x的祖宗节点，并压缩路径\n&#123;\n    if(p[x] != x)p[x] = find(p[x]);\n    return p[x];\n&#125;\n\n// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]\n\n//如果要合并两个节点，则\nvoid merge(int a,int b)&#123;\n    //if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步\n    size[find(b)] += size[find(a)];  //必须先加size，再合并（a,b）\n    p[find(a)] = find(b);\n    //加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义\n    //如果先合并再相加，则代表两个相同的集合数量相加\n&#125;\n</code></pre>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\n//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了\nconst int N = 2e5 + 3;\t\t\t\t//大于数据范围的第一个质数\nconst int null = 0x3f3f3f3f;\t\t//规定空指针为 null 0x3f3f3f3f\n\nint h[N];\n\nint find(int x) &#123;\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x) &#123;\n        t++;\n        if (t == N) &#123;\n            t = 0;\n        &#125;\n    &#125;\n    return t;\t//如果这个位置是空的, 则返回的是他应该存储的位置\n&#125;\n\nint main() &#123;\n    int n;\n    scanf(&quot;%d&quot;, &amp;n);\n    memset(h, null, sizeof(h));\n\n    while (n --) &#123;\n        char op[2];\n        int x;\n        scanf(&quot;%s%d&quot;, op, &amp;x);\n        if (op[0] == &#39;I&#39;) &#123;\n            h[find(x)] = x;\n        &#125; else &#123;\n            if (h[find(x)] == null) &#123;\n                printf(&quot;No&quot;);\n            &#125; else &#123;\n                printf(&quot;Yes&quot;);\n            &#125;\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"字符串哈希表\"><a href=\"#字符串哈希表\" class=\"headerlink\" title=\"字符串哈希表\"></a>字符串哈希表</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230318194927056.png\" alt=\"image-20230318194927056\"></p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nint const N = 10000010, P = 131; //P = 131 或者是 13331 Q一般取 2^64\n// P 代表进制 \n\nULL h[N], p[N];\nchar a[N];\n\nULL query(int l, int r) &#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main() &#123;\n    int n, m;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    scanf(&quot;%s&quot;, a + 1);\n\n    h[0] = 0, p[0] = 1;\n    for (int i = 1; i &lt;= n; i ++) &#123;\n        h[i] = h[i - 1] * P + a[i];\n        p[i] = p[i - 1] * P;\n    &#125;\n\n    while (m --) &#123;\n        int l1, l2, r1, r2;\n        scanf(&quot;%d %d %d %d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);\n        if (query(l1, r1) == query(l2, r2))\n            printf(&quot;Yes\\n&quot;);\n        else\n            printf(&quot;No\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230323161436730.png\" alt=\"image-20230323161436730\"></p>\n<h2 id=\"最小根堆\"><a href=\"#最小根堆\" class=\"headerlink\" title=\"最小根堆\"></a>最小根堆</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#icnlude &lt;vector&gt;\n\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\nheap.push(x), x = heap.top(), heap.pop();\n//每次弹出来的顶端都是最小值，并且push后堆会自动排序\n</code></pre>\n<h2 id=\"关于sort-函数\"><a href=\"#关于sort-函数\" class=\"headerlink\" title=\"关于sort()函数\"></a>关于sort()函数</h2><pre><code class=\"c\">int num[100];\nbool cmp(int a,int b)&#123;\n    return a &gt; b;\t\t\t\t\t\t\t\t //a&gt;b为由大到小，b&lt;a为由小到大\n&#125;\nsort(num,num+100,cmp);\n</code></pre>\n<pre><code class=\"c++\">struct Edge&#123;\n    int a, b , w;\n&#125;edges[N];\n\nbool cmp(Edge a, Edge b)&#123;\t\t\t\t\t\t//按照w的大小排序，此时为递增\n    return a.w &lt; b.w;\n&#125;\n\nsort(edges, edges + m, cmp);\n</code></pre>\n<pre><code class=\"c++\">//可以自定义排序\nbool cmp(int x,int y)&#123;\t\t\t\t\t//按照个位数的大小排序，此时为递增\n    return x % 10 &lt; y % 10;\n&#125;\n</code></pre>\n<ol>\n<li>sort(首地址，尾地址+1，cmp)</li>\n<li>这个函数可以传两个或者三个参数</li>\n<li>第一个参数是要排序的区间首地址</li>\n<li>第二个参数是区间尾地址的下一个地址</li>\n<li>第三个参数不写,则为递增排序</li>\n</ol>\n<h2 id=\"求最大公约数、最小公倍数\"><a href=\"#求最大公约数、最小公倍数\" class=\"headerlink\" title=\"求最大公约数、最小公倍数\"></a>求最大公约数、最小公倍数</h2><pre><code class=\"c++\">int gcd(int a, int b)&#123;\t//最大公约数\n    return b ? gcd(b, a % b) : a;\n&#125;\n\nint gcb(int a, int b)&#123;\t//最小公倍数\n    return a * b / gcd(a, b);\n&#125;\n</code></pre>\n<h2 id=\"取模\"><a href=\"#取模\" class=\"headerlink\" title=\"取模\"></a>取模</h2><p>同余定理：x%mod&#x3D;(x+mod)%mod</p>\n<h2 id=\"无穷大\"><a href=\"#无穷大\" class=\"headerlink\" title=\"无穷大\"></a>无穷大</h2><p>inf &#x3D; 0x3f3f3f3f</p>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223240363.png\" alt=\"image-20230406223240363\"></p>\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223251946.png\" alt=\"image-20230406223251946\"></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint a[N], tmp[N];\n\nvoid merge_sort(int l, int r)&#123;\n    if(l &gt;= r) return ;\n    \n    int mid = l + r &gt;&gt; 1;\n    merge_sort(l, mid), merge_sort(mid + 1, r);\n    \n    int k = 0, i = l, j = mid + 1;\n    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;\n        if(a[i] &lt;= a[j]) tmp[k ++] = a[i ++];\n        else tmp[k ++] = a[j ++];\n    &#125;\n    \n    while(i &lt;= mid) tmp[k ++] = a[i ++];\n    while(j &lt;= r) tmp[k ++] = a[j ++];\n    \n    for (int i = l, j = 0; i &lt;= r; i ++, j ++) a[i] = tmp[j];\n&#125;\n</code></pre>\n<h2 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h2><p>初始化</p>\n<pre><code class=\"c++\">int e[N], ne[N], h[N], w[N], dist[N], idx;\nint n, m;\nbool st[N];\n\nvoid add(int a, int b, int c) &#123;\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    memset(h, -1, sizeof h);\n&#125;\n</code></pre>\n<h3 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h3><p>朴素版</p>\n<p>题型：稠密图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<pre><code class=\"c++\">int dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j++)\n        &#123;\n            if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n                t = j;\n        &#125;\n        visited[t] = true;\n        for(int j = 1; j &lt;= n; j++)\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n    &#125;\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n</code></pre>\n<p>堆优化</p>\n<p>题型：稀疏图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<pre><code class=\"c++\">int dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆\n    // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，\n    // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。\n    heap.push(&#123; 0, 1 &#125;); // 这个顺序不能倒，pair排序时是先根据first，再根据second，\n                         // 这里显然要根据距离排序\n    while(heap.size())\n    &#123;\n        PII k = heap.top(); // 取不在集合S中距离最短的点\n        heap.pop();\n        int ver = k.second, distance = k.first;\n\n        if(st[ver]) continue;\n        st[ver] = true;\n\n        for(int i = h[ver]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。\n            if(dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] = distance + w[i];\n                heap.push(&#123; dist[j], j &#125;);\n            &#125;\n        &#125;\n    &#125;\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    else return dist[n];\n&#125;\n</code></pre>\n<h3 id=\"Spfa算法\"><a href=\"#Spfa算法\" class=\"headerlink\" title=\"Spfa算法\"></a>Spfa算法</h3><p>可用于负权图</p>\n<pre><code class=\"c++\">dist[j] = dist[t] + w[i] //当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边\n</code></pre>\n<pre><code class=\"c++\">int spfa()&#123;\n    queue&lt;PII&gt; q;\n    memset(dist,0x3f,sizeof dist);\n    dist[1]=0;\n    q.push(&#123;0,1&#125;);\n    st[1]=true;\n    while(q.size())&#123;\n        PII p=q.front();\n        q.pop();\n        int t=p.se;\n        st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队\n        for(int i=h[t];i!=-1;i=ne[i])&#123;\n            int j=e[i];\n            if(dist[j]&gt;dist[t]+w[i])&#123;\n                dist[j]=dist[t]+w[i];\n                if(!st[j])&#123;//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率\n                    st[j]=true;\n                    q.push(&#123;dist[j],j&#125;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if(dist[n]==0x3f3f3f3f) return -1;\n    else return dist[n];\n&#125;\n</code></pre>\n<p>如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。</p>\n<pre><code class=\"c++\">bool spfa() &#123;\n    queue&lt;int&gt; q;\n\n    for (int i = 1; i &lt;= n; i ++) &#123;//需要判断的是有无负权回路，则应该是从每个点开始遍历\n        q.push(i);\n        st[i] = true;\n    &#125;\n\n    while (q.size()) &#123;\n        int t = q.front();\n\n        q.pop();\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i]) &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) &#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] &gt; n)\n                    return true;\n                if (!st[j]) &#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<pre><code class=\"c++\">void spfa() &#123;\t\t//从 start 到 ed 的最小权重\n    memset(dist, 0x3f, sizeof dist);\n\n    dist[start] = 0;\n\n    q[0] = start, st[start] = true;\n\n    int hh = 0, tt = 1;\n    while (hh != tt) &#123;\n        int t = q[hh ++];\n        if (hh == N)\t\t\n            hh = 0;\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i]) &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) &#123;\n                dist[j] = dist[t] + w[i];\n                if (!st[j]) &#123;\n                    q[tt ++] = j;\n                    if (tt == N)\n                        tt = 0;\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"Bellman-ford算法\"><a href=\"#Bellman-ford算法\" class=\"headerlink\" title=\"Bellman_ford算法\"></a>Bellman_ford算法</h3><p>可用于负权回路图。</p>\n<p>1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路</p>\n<p>核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f &#x2F; 2 ，即无法用 k 步走到 n 点</p>\n<pre><code class=\"c++\">int bellman_ford() &#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i &lt; k; i++) &#123;//k次循环\n        memcpy(back, dist, sizeof dist);\n        for (int j = 0; j &lt; m; j++) &#123;//遍历所有边\n            int a = e[j].a, b = e[j].b, w = e[j].w;\n            dist[b] = min(dist[b], back[a] + w);\n            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来\n        &#125;\n    &#125;\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    else return dist[n];\n\n&#125;\n</code></pre>\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>题型：<strong>稠密图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：从 n 个点中选出一个离当前生成树的最小路径，res +&#x3D;该路径，并且用这个点更新其余的点（ dist[ j ] &#x3D; min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] &#x3D; INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。</p>\n<pre><code class=\"c++\">int Prim() &#123;\n    memset(dist, 0x3f, sizeof dist);\n    //dist[j]： 点j到目前生成树的距离\n    int res = 0;\n    for (int i = 0; i &lt; n; i ++) &#123;\n        int t = -1;\n        for (int j = 1; j &lt;= n; j ++) &#123;\n            if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n                t = j;\n        &#125;\n\n        if (i)\n            res += dist[t];\n\n        for (int j = 1; j &lt;= n; j ++) &#123;\n            dist[j] = min(dist[j], g[t][j]);\n        &#125;\n\n        if (i &amp;&amp; dist[t] == INF)\n            return INF;\n        st[t] = true;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>题型：<strong>稀疏图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res +&#x3D; 边权值，cnt ++。 </p>\n<pre><code class=\"c++\">int main()&#123;\nsort(edges, edges + m, cmp);\n\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i ++) &#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n        a = find(a), b = find(b);\n        if (a != b) &#123;\n            res += w;\n            cnt ++;\n            p[a] = b;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1)//边数小于 n - 1 说明有孤立点 \n        printf(&quot;impossible&quot;);\n    else\n        printf(&quot;%d&quot;, res);\n&#125;\n</code></pre>\n<h3 id=\"染色法判定二分图\"><a href=\"#染色法判定二分图\" class=\"headerlink\" title=\"染色法判定二分图\"></a>染色法判定二分图</h3><p>题型：判断二分图</p>\n<p>思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图</p>\n<pre><code class=\"c++\">bool DFS(int u, int c) &#123;\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i]) &#123;\n        int j = e[i];\n        if (!color[j]) &#123;\n            if (!DFS(j, 3 - c))\n                return false;\n        &#125; else if (color[j] == c)\n            return false;\n    &#125;\n    return true;\n&#125;\n\nint main()&#123;\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i ++) &#123;\n        if (!color[i]) &#123;\n            if (!DFS(i, 1)) &#123;\n                flag = false;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    if (flag)\n        printf(&quot;Yes&quot;);\n    else\n        printf(&quot;No&quot;);\n&#125;\n</code></pre>\n<h3 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h3><p>题型：邻接表，求二分图的最大匹配</p>\n<p>思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配），</p>\n<p>如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] &#x3D; x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。</p>\n<pre><code class=\"c++\">bool find(int x) &#123;\t\t\t//帮助男生 x 匹配女生，成功返回true，否则返回false\n    for (int i = h[x]; i != -1; i = ne[i]) &#123;\n        int j = e[i];\n        if (!st[j]) &#123;\n            st[j] = true;\n            if (match[j] == 0 || find(match[j])) &#123;\n                match[j] = x;\t\t//match[j]代表 女生 j 的匹配的男生为 match[j]\n                return true;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    for (int i = 1; i &lt;= n1; i ++) &#123;\n        memset(st, false, sizeof st);\n        if (find(i))\n            res ++;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"数位Dp\"><a href=\"#数位Dp\" class=\"headerlink\" title=\"数位Dp\"></a>数位Dp</h2><p>把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算</p>\n<pre><code class=\"c++\">int dp(int n)&#123;\n    if (n == 0) return 0;\n\n    vector&lt;int&gt; nums;\n    while(n) nums.push_back(n % B), n /= B;\n\n    int res = 0, last = 0;\n    for (int i = nums.size() - 1; i &gt;= 0; i -- )&#123;\n        int x = nums[i];\n\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h2 id=\"树的最长路径\"><a href=\"#树的最长路径\" class=\"headerlink\" title=\"树的最长路径\"></a>树的最长路径</h2><pre><code class=\"c++\">void dfs(int u, int father)//防止从下往上遍历，引入 father\n&#123;\n    f1[u] = f2[u] = 0;//从 u 点出发， f1 为最长的路径， f2 为第二长的路径\n    for (int i = h[u]; ~i; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (j == father) continue;\n        dfs(j, u);\n        if (f1[j] + w[i] &gt;= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; //最长路转移\n        else if (f1[j] + w[i] &gt; f2[u]) f2[u] = f1[j] + w[i];            //次长路转移\n    &#125;\n    res = max(res, f1[u] + f2[u]);\n&#125;\n</code></pre>\n<h2 id=\"Flood-Fill\"><a href=\"#Flood-Fill\" class=\"headerlink\" title=\"Flood Fill\"></a>Flood Fill</h2><p>求连通块的数量</p>\n<pre><code class=\"c++\">void bfs(int sx, int sy)&#123;\n    st[sx][sy] = true;\n    q[0] = &#123;sx, sy&#125;;\n\n    int hh = 0, tt = 0;\n    while(hh &lt;= tt)&#123;\n        PII t = q[hh ++];\n        for (int i = t.x - 1; i &lt;= t.x + 1; i ++ )\n            for (int j = t.y - 1; j &lt;= t.y + 1; j ++ )&#123;\n                if (i == t.x &amp;&amp; j == t.y) continue;\n                if (g[i][j] == &#39;.&#39; || st[i][j]) continue;\n                if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue;\n                q[ ++ tt] = &#123;i, j&#125;;\n                st[i][j] = true;\n            &#125;\n    &#125;\n&#125;\n\nint cnt = 0;\n    for (int i = 0; i &lt; n; i ++ )\n        for (int j = 0; j &lt; m; j ++ )&#123;\n            if (g[i][j] == &#39;W&#39; &amp;&amp; !st[i][j])&#123; //需要联通的条件，并且该点没有遍历\n                bfs(i, j);\n                cnt ++;\n            &#125;\n        &#125;\n</code></pre>\n<pre><code class=\"c++\">int bfs()&#123;\t//求最短路径\n    memset(dist, -1, sizeof dist);//定义所有点都没有遍历\n    \n    int sx, sy;\n    for (int i = 0; i &lt; n; i ++ )\n        for (int j = 0; j &lt; m; j ++ )\n            if (g[i][j] == &#39;K&#39;)&#123;\n                sx = i, sy = j;\n            &#125;\n    \n    int hh = 0, tt = 0;\n    q[0] = &#123;sx, sy&#125;;\n    dist[sx][sy] = 0;//起始点的距离为0\n    while(hh &lt;= tt)&#123;\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i &lt; 8; i ++ )&#123;\n            int a = t.x + dx[i], b = t.y + dy[i];//枚举下一个点\n            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m) continue;\n            if (g[a][b] == &#39;*&#39;) continue;\n            if (dist[a][b] != -1) continue;//表示下一个点有没有遍历\n            if (g[a][b] == &#39;H&#39;) return dist[t.x][t.y] + 1;\n\n            dist[a][b] = dist[t.x][t.y] + 1;\n            q[ ++ tt] = &#123;a, b&#125;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"c++\">void bfs(int sx, int sy)&#123;//求最短路径，并且输出路径\n    int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, -1, 0, 1&#125;;\n\n    int hh = 0, tt = 0;\n    q[0] = &#123;sx, sy&#125;;\n\n    memset(pre, -1, sizeof pre);//pre 用于存储路径\n    pre[sx][sy] = &#123;0, 0&#125;;\n//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的\n    while (hh &lt;= tt)&#123;\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i &lt; 4; i ++ )&#123;\n            int a = t.x + dx[i], b = t.y + dy[i];\n            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue;\n            if (g[a][b]) continue;\n            if (pre[a][b].x != -1) continue;\n\n            q[ ++ tt] = &#123;a, b&#125;;\n            pre[a][b] = t;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h2><h3 id=\"线性筛法求素数\"><a href=\"#线性筛法求素数\" class=\"headerlink\" title=\"线性筛法求素数\"></a>线性筛法求素数</h3><pre><code class=\"c++\">int primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        &#123;\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h3><pre><code class=\"c++\">int gcd(int a, int b)//求最大公约数\n&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\n</code></pre>\n<h3 id=\"试除法求所有约数\"><a href=\"#试除法求所有约数\" class=\"headerlink\" title=\"试除法求所有约数\"></a>试除法求所有约数</h3><pre><code class=\"c++\">vector&lt;int&gt; get_divisors(int x)\n&#123;\n    vector&lt;int&gt; res;\n    for (int i = 1; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        &#123;\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);//防止相同的数\n        &#125;\n    sort(res.begin(), res.end());\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"筛法求欧拉函数\"><a href=\"#筛法求欧拉函数\" class=\"headerlink\" title=\"筛法求欧拉函数\"></a>筛法求欧拉函数</h3><pre><code class=\"c++\">int primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n&#123;\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (!st[i])\n        &#123;\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        &#125;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        &#123;\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            &#123;\n                euler[t] = euler[i] * primes[j];\n                break;\n            &#125;\n            euler[t] = euler[i] * (primes[j] - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h3><pre><code class=\"c++\">int qmi(int m, int k, int p)\n&#123;\n    int res = 1 % p, t = m;\n    while (k)\n    &#123;\n        if (k &amp; 1) res = res * t % p;\n        t = t * t % p;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a>扩展欧几里得算法</h3><pre><code class=\"c++\">// 求x, y，使得ax + by = gcd(a, b)\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if (!b)\n    &#123;\n        x = 1; y = 0;\n        return a;\n    &#125;\n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;\n    return d;\n&#125;\n</code></pre>\n","excerpt":"","more":"<h2 id=\"C-头文件\"><a href=\"#C-头文件\" class=\"headerlink\" title=\"C++头文件\"></a>C++头文件</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;cstring&gt;\n#include &lt;queue&gt;\n#include &lt;unordered_map&gt;\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\ntypedef pair&lt;int, int&gt; PII\n\nvector&lt;int&gt; alls;\n</code></pre>\n<h2 id=\"string-的函数\"><a href=\"#string-的函数\" class=\"headerlink\" title=\"string 的函数\"></a>string 的函数</h2><pre><code class=\"c++\">int main()&#123;\n    string a;\n    a.substr(0, k) //从 a[0] 开始到 a[k] ，返回这段字符串\n    a.substr(1)  //从 a[1] 开始到末尾，返回这段字符串\n&#125;\n</code></pre>\n<h2 id=\"排列组合\"><a href=\"#排列组合\" class=\"headerlink\" title=\"排列组合\"></a>排列组合</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192125061.png\" alt=\"image-20221215192125061\"><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20221215192152255.png\" alt=\"image-20221215192152255\"></p>\n<pre><code class=\"c++\">//从m个数里抽出n个数，进行全排列\nint arrange(int m,int n)&#123;\n    if(m==n)return n;\n    return m*arrange(m-1,n);\n&#125;\n\n//从m个数里抽出n个数，进行组合排序\n//法一\nint cnm(int n,int m)&#123;\n    if(n==1)return m;\n    return m*cnm(n-1,m-1)/n;\n&#125;\n//法二\nint cnm(int n,int m)&#123;\n    if(n==1)return m;\n    if(n==m)return 1;\n    return (cnm(n,m-1)+cnm(n-1,m-1));\n&#125;\n\n//法三  从 i 个数里抽出 j 个数的方案数\nvoid init()&#123;\n    for (int i = 0; i &lt; N; i ++ )\n        for (int j = 0; j &lt;= i; j ++ )&#123;\n            if (!j) f[i][j] = 1;\n            else f[i][j] = f[i - 1][j] + f[i - 1][j - 1];\n        &#125;\n&#125;\n</code></pre>\n<h2 id=\"二位前缀和\"><a href=\"#二位前缀和\" class=\"headerlink\" title=\"二位前缀和\"></a>二位前缀和</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230314194756707.png\" alt=\"image-20230314194756707\"></p>\n<h2 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h2><p>在数组a[l,r]区间内加上c，则可表示为a[l]+&#x3D;c,a[r+1]+&#x3D;-c</p>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><p>x&gt;&gt;1，代表x右移一位，值变成1&#x2F;2；x&lt;&lt;1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。</p>\n<p>x &gt;&gt; k &amp; 1 , 代表 x 的第 k 位是否为 1.</p>\n<pre><code class=\"c\">int lowbit(int x)&#123;\t\t\t//返回最后一个1的位数\n    return x&amp;-x;\t\t\t/*例如 10 的二进制为 1010，则返回 10*/\n&#125;\n</code></pre>\n<h2 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h2><pre><code class=\"c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nvector&lt;int&gt; alls;//储存所有待离散化的值\nsort(alls.begin(),alls.end());//将所有的值排序\nalls.erase(unique(alls.begin(),alls,end),alls.end);//去掉重复元素\n\n//二分法求出x对应的离散化的值\nint find(int x)&#123;\n    int l = 0, r = alls.size() - 1;\n    while(l &lt; r)&#123;\n        int mid = l + r;\n        if(alls[mid] &gt;= x)&#123;\n            r = mid;\n        &#125;\n        else&#123;\n            l = mid +1;\n        &#125;\n    &#125;\n    return r + 1;//返回 1，2，3，4……\n&#125;\n</code></pre>\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 100010, M = 10010; //N为模式串长度，M匹配串长度\n\nint n, m;\nint ne[M]; //next[]数组，避免和头文件next冲突\nchar s[N], p[M];  //s为模式串， p为匹配串\n\nint main()\n&#123;\n    cin &gt;&gt; n &gt;&gt; s+1 &gt;&gt; m &gt;&gt; p+1;  //下标从1开始\n\n    //求next[]数组\n    for(int i = 2, j = 0; i &lt;= m; i++)\n    &#123;\n        while(j &amp;&amp; p[i] != p[j+1]) j = ne[j];\n        if(p[i] == p[j+1]) j++;\n        ne[i] = j;\n    &#125;\n    //匹配操作\n    for(int i = 1, j = 0; i &lt;= n; i++)\n    &#123;\n        while(j &amp;&amp; s[i] != p[j+1]) j = ne[j];\n        if(s[i] == p[j+1]) j++;\n        if(j == m)  //满足匹配条件，打印开头下标, 从0开始\n        &#123;\n            //匹配完成后的具体操作\n            //如：输出以0开始的匹配子串的首字母下标\n            //printf(&quot;%d &quot;, i - m); (若从1开始，加1)\n            j = ne[j];            //再次继续匹配\n        &#125;\n    &#125;\n\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230317125934107.png\" alt=\"image-20230317125934107\"></p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\nusing namespace std;\n\nconst int N = 100010;\n\nint son[N][26], cnt[N], idx = 0;\n\nvoid insert(char str[]) &#123;\n    int p = 0;\n    for (int i = 0; str[i]; i++) &#123;\n        int u = str[i] - &#39;a&#39;;\n        if (son[p][u] == 0)\n            son[p][u] = ++idx;\n        p = son[p][u];\n    &#125;\n    cnt[p]++;\n&#125;\n\nint query(char str[]) &#123;\n    int p = 0;\n    for (int i = 0; str[i]; i++) &#123;\n        int u = str[i] - &#39;a&#39;;\n        if (son[p][u] == 0)\n            return 0;\n        p = son[p][u];\n    &#125;\n    return cnt[p];\n&#125;\n</code></pre>\n<h2 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h2><pre><code class=\"c++\">int find(int x)//返回x的祖宗节点，并压缩路径\n&#123;\n    if(p[x] != x)p[x] = find(p[x]);\n    return p[x];\n&#125;\n\n// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]\n\n//如果要合并两个节点，则\nvoid merge(int a,int b)&#123;\n    //if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步\n    size[find(b)] += size[find(a)];  //必须先加size，再合并（a,b）\n    p[find(a)] = find(b);\n    //加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义\n    //如果先合并再相加，则代表两个相同的集合数量相加\n&#125;\n</code></pre>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\n//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了\nconst int N = 2e5 + 3;\t\t\t\t//大于数据范围的第一个质数\nconst int null = 0x3f3f3f3f;\t\t//规定空指针为 null 0x3f3f3f3f\n\nint h[N];\n\nint find(int x) &#123;\n    int t = (x % N + N) % N;\n    while (h[t] != null &amp;&amp; h[t] != x) &#123;\n        t++;\n        if (t == N) &#123;\n            t = 0;\n        &#125;\n    &#125;\n    return t;\t//如果这个位置是空的, 则返回的是他应该存储的位置\n&#125;\n\nint main() &#123;\n    int n;\n    scanf(&quot;%d&quot;, &amp;n);\n    memset(h, null, sizeof(h));\n\n    while (n --) &#123;\n        char op[2];\n        int x;\n        scanf(&quot;%s%d&quot;, op, &amp;x);\n        if (op[0] == &#39;I&#39;) &#123;\n            h[find(x)] = x;\n        &#125; else &#123;\n            if (h[find(x)] == null) &#123;\n                printf(&quot;No&quot;);\n            &#125; else &#123;\n                printf(&quot;Yes&quot;);\n            &#125;\n            printf(&quot;\\n&quot;);\n        &#125;\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"字符串哈希表\"><a href=\"#字符串哈希表\" class=\"headerlink\" title=\"字符串哈希表\"></a>字符串哈希表</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230318194927056.png\" alt=\"image-20230318194927056\"></p>\n<pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\ntypedef unsigned long long ULL;\n\nint const N = 10000010, P = 131; //P = 131 或者是 13331 Q一般取 2^64\n// P 代表进制 \n\nULL h[N], p[N];\nchar a[N];\n\nULL query(int l, int r) &#123;\n    return h[r] - h[l - 1] * p[r - l + 1];\n&#125;\n\nint main() &#123;\n    int n, m;\n    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);\n    scanf(&quot;%s&quot;, a + 1);\n\n    h[0] = 0, p[0] = 1;\n    for (int i = 1; i &lt;= n; i ++) &#123;\n        h[i] = h[i - 1] * P + a[i];\n        p[i] = p[i - 1] * P;\n    &#125;\n\n    while (m --) &#123;\n        int l1, l2, r1, r2;\n        scanf(&quot;%d %d %d %d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);\n        if (query(l1, r1) == query(l2, r2))\n            printf(&quot;Yes\\n&quot;);\n        else\n            printf(&quot;No\\n&quot;);\n    &#125;\n    return 0;\n&#125;\n</code></pre>\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230323161436730.png\" alt=\"image-20230323161436730\"></p>\n<h2 id=\"最小根堆\"><a href=\"#最小根堆\" class=\"headerlink\" title=\"最小根堆\"></a>最小根堆</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#icnlude &lt;vector&gt;\n\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;\nheap.push(x), x = heap.top(), heap.pop();\n//每次弹出来的顶端都是最小值，并且push后堆会自动排序\n</code></pre>\n<h2 id=\"关于sort-函数\"><a href=\"#关于sort-函数\" class=\"headerlink\" title=\"关于sort()函数\"></a>关于sort()函数</h2><pre><code class=\"c\">int num[100];\nbool cmp(int a,int b)&#123;\n    return a &gt; b;\t\t\t\t\t\t\t\t //a&gt;b为由大到小，b&lt;a为由小到大\n&#125;\nsort(num,num+100,cmp);\n</code></pre>\n<pre><code class=\"c++\">struct Edge&#123;\n    int a, b , w;\n&#125;edges[N];\n\nbool cmp(Edge a, Edge b)&#123;\t\t\t\t\t\t//按照w的大小排序，此时为递增\n    return a.w &lt; b.w;\n&#125;\n\nsort(edges, edges + m, cmp);\n</code></pre>\n<pre><code class=\"c++\">//可以自定义排序\nbool cmp(int x,int y)&#123;\t\t\t\t\t//按照个位数的大小排序，此时为递增\n    return x % 10 &lt; y % 10;\n&#125;\n</code></pre>\n<ol>\n<li>sort(首地址，尾地址+1，cmp)</li>\n<li>这个函数可以传两个或者三个参数</li>\n<li>第一个参数是要排序的区间首地址</li>\n<li>第二个参数是区间尾地址的下一个地址</li>\n<li>第三个参数不写,则为递增排序</li>\n</ol>\n<h2 id=\"求最大公约数、最小公倍数\"><a href=\"#求最大公约数、最小公倍数\" class=\"headerlink\" title=\"求最大公约数、最小公倍数\"></a>求最大公约数、最小公倍数</h2><pre><code class=\"c++\">int gcd(int a, int b)&#123;\t//最大公约数\n    return b ? gcd(b, a % b) : a;\n&#125;\n\nint gcb(int a, int b)&#123;\t//最小公倍数\n    return a * b / gcd(a, b);\n&#125;\n</code></pre>\n<h2 id=\"取模\"><a href=\"#取模\" class=\"headerlink\" title=\"取模\"></a>取模</h2><p>同余定理：x%mod&#x3D;(x+mod)%mod</p>\n<h2 id=\"无穷大\"><a href=\"#无穷大\" class=\"headerlink\" title=\"无穷大\"></a>无穷大</h2><p>inf &#x3D; 0x3f3f3f3f</p>\n<h2 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h2><p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223240363.png\" alt=\"image-20230406223240363\"></p>\n<p><img src=\"/../image/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/image-20230406223251946.png\" alt=\"image-20230406223251946\"></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><pre><code class=\"c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n\nconst int N = 1e5 + 5;\nint a[N], tmp[N];\n\nvoid merge_sort(int l, int r)&#123;\n    if(l &gt;= r) return ;\n    \n    int mid = l + r &gt;&gt; 1;\n    merge_sort(l, mid), merge_sort(mid + 1, r);\n    \n    int k = 0, i = l, j = mid + 1;\n    while(i &lt;= mid &amp;&amp; j &lt;= r)&#123;\n        if(a[i] &lt;= a[j]) tmp[k ++] = a[i ++];\n        else tmp[k ++] = a[j ++];\n    &#125;\n    \n    while(i &lt;= mid) tmp[k ++] = a[i ++];\n    while(j &lt;= r) tmp[k ++] = a[j ++];\n    \n    for (int i = l, j = 0; i &lt;= r; i ++, j ++) a[i] = tmp[j];\n&#125;\n</code></pre>\n<h2 id=\"图论\"><a href=\"#图论\" class=\"headerlink\" title=\"图论\"></a>图论</h2><p>初始化</p>\n<pre><code class=\"c++\">int e[N], ne[N], h[N], w[N], dist[N], idx;\nint n, m;\nbool st[N];\n\nvoid add(int a, int b, int c) &#123;\n    e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;\n&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n    memset(h, -1, sizeof h);\n&#125;\n</code></pre>\n<h3 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h3><p>朴素版</p>\n<p>题型：稠密图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<pre><code class=\"c++\">int dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    for(int i = 1; i &lt;= n; i++)\n    &#123;\n        int t = -1;\n        for(int j = 1; j &lt;= n; j++)\n        &#123;\n            if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n                t = j;\n        &#125;\n        visited[t] = true;\n        for(int j = 1; j &lt;= n; j++)\n            dist[j] = min(dist[j], dist[t] + g[t][j]);\n    &#125;\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n&#125;\n</code></pre>\n<p>堆优化</p>\n<p>题型：稀疏图</p>\n<p>思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边</p>\n<pre><code class=\"c++\">int dijkstra()\n&#123;\n    memset(dist, 0x3f, sizeof(dist));\n    dist[1] = 0;\n    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆\n    // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，\n    // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。\n    heap.push(&#123; 0, 1 &#125;); // 这个顺序不能倒，pair排序时是先根据first，再根据second，\n                         // 这里显然要根据距离排序\n    while(heap.size())\n    &#123;\n        PII k = heap.top(); // 取不在集合S中距离最短的点\n        heap.pop();\n        int ver = k.second, distance = k.first;\n\n        if(st[ver]) continue;\n        st[ver] = true;\n\n        for(int i = h[ver]; i != -1; i = ne[i])\n        &#123;\n            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。\n            if(dist[j] &gt; distance + w[i])\n            &#123;\n                dist[j] = distance + w[i];\n                heap.push(&#123; dist[j], j &#125;);\n            &#125;\n        &#125;\n    &#125;\n    if(dist[n] == 0x3f3f3f3f) return -1;\n    else return dist[n];\n&#125;\n</code></pre>\n<h3 id=\"Spfa算法\"><a href=\"#Spfa算法\" class=\"headerlink\" title=\"Spfa算法\"></a>Spfa算法</h3><p>可用于负权图</p>\n<pre><code class=\"c++\">dist[j] = dist[t] + w[i] //当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边\n</code></pre>\n<pre><code class=\"c++\">int spfa()&#123;\n    queue&lt;PII&gt; q;\n    memset(dist,0x3f,sizeof dist);\n    dist[1]=0;\n    q.push(&#123;0,1&#125;);\n    st[1]=true;\n    while(q.size())&#123;\n        PII p=q.front();\n        q.pop();\n        int t=p.se;\n        st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队\n        for(int i=h[t];i!=-1;i=ne[i])&#123;\n            int j=e[i];\n            if(dist[j]&gt;dist[t]+w[i])&#123;\n                dist[j]=dist[t]+w[i];\n                if(!st[j])&#123;//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率\n                    st[j]=true;\n                    q.push(&#123;dist[j],j&#125;);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    if(dist[n]==0x3f3f3f3f) return -1;\n    else return dist[n];\n&#125;\n</code></pre>\n<p>如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。</p>\n<pre><code class=\"c++\">bool spfa() &#123;\n    queue&lt;int&gt; q;\n\n    for (int i = 1; i &lt;= n; i ++) &#123;//需要判断的是有无负权回路，则应该是从每个点开始遍历\n        q.push(i);\n        st[i] = true;\n    &#125;\n\n    while (q.size()) &#123;\n        int t = q.front();\n\n        q.pop();\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i]) &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) &#123;\n                dist[j] = dist[t] + w[i];\n                cnt[j] = cnt[t] + 1;\n                if (cnt[j] &gt; n)\n                    return true;\n                if (!st[j]) &#123;\n                    st[j] = true;\n                    q.push(j);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n</code></pre>\n<pre><code class=\"c++\">void spfa() &#123;\t\t//从 start 到 ed 的最小权重\n    memset(dist, 0x3f, sizeof dist);\n\n    dist[start] = 0;\n\n    q[0] = start, st[start] = true;\n\n    int hh = 0, tt = 1;\n    while (hh != tt) &#123;\n        int t = q[hh ++];\n        if (hh == N)\t\t\n            hh = 0;\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i]) &#123;\n            int j = e[i];\n            if (dist[j] &gt; dist[t] + w[i]) &#123;\n                dist[j] = dist[t] + w[i];\n                if (!st[j]) &#123;\n                    q[tt ++] = j;\n                    if (tt == N)\n                        tt = 0;\n                    st[j] = true;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"Bellman-ford算法\"><a href=\"#Bellman-ford算法\" class=\"headerlink\" title=\"Bellman_ford算法\"></a>Bellman_ford算法</h3><p>可用于负权回路图。</p>\n<p>1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路</p>\n<p>核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f &#x2F; 2 ，即无法用 k 步走到 n 点</p>\n<pre><code class=\"c++\">int bellman_ford() &#123;\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n    for (int i = 0; i &lt; k; i++) &#123;//k次循环\n        memcpy(back, dist, sizeof dist);\n        for (int j = 0; j &lt; m; j++) &#123;//遍历所有边\n            int a = e[j].a, b = e[j].b, w = e[j].w;\n            dist[b] = min(dist[b], back[a] + w);\n            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来\n        &#125;\n    &#125;\n    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;\n    else return dist[n];\n\n&#125;\n</code></pre>\n<h3 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h3><p>题型：<strong>稠密图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：从 n 个点中选出一个离当前生成树的最小路径，res +&#x3D;该路径，并且用这个点更新其余的点（ dist[ j ] &#x3D; min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] &#x3D; INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。</p>\n<pre><code class=\"c++\">int Prim() &#123;\n    memset(dist, 0x3f, sizeof dist);\n    //dist[j]： 点j到目前生成树的距离\n    int res = 0;\n    for (int i = 0; i &lt; n; i ++) &#123;\n        int t = -1;\n        for (int j = 1; j &lt;= n; j ++) &#123;\n            if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t]))\n                t = j;\n        &#125;\n\n        if (i)\n            res += dist[t];\n\n        for (int j = 1; j &lt;= n; j ++) &#123;\n            dist[j] = min(dist[j], g[t][j]);\n        &#125;\n\n        if (i &amp;&amp; dist[t] == INF)\n            return INF;\n        st[t] = true;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h3><p>题型：<strong>稀疏图</strong>，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小）</p>\n<p>思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res +&#x3D; 边权值，cnt ++。 </p>\n<pre><code class=\"c++\">int main()&#123;\nsort(edges, edges + m, cmp);\n\n    int res = 0, cnt = 0;\n    for (int i = 0; i &lt; m; i ++) &#123;\n        int a = edges[i].a, b = edges[i].b, w = edges[i].w;\n\n        a = find(a), b = find(b);\n        if (a != b) &#123;\n            res += w;\n            cnt ++;\n            p[a] = b;\n        &#125;\n    &#125;\n\n    if (cnt &lt; n - 1)//边数小于 n - 1 说明有孤立点 \n        printf(&quot;impossible&quot;);\n    else\n        printf(&quot;%d&quot;, res);\n&#125;\n</code></pre>\n<h3 id=\"染色法判定二分图\"><a href=\"#染色法判定二分图\" class=\"headerlink\" title=\"染色法判定二分图\"></a>染色法判定二分图</h3><p>题型：判断二分图</p>\n<p>思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图</p>\n<pre><code class=\"c++\">bool DFS(int u, int c) &#123;\n    color[u] = c;\n    for (int i = h[u]; i != -1; i = ne[i]) &#123;\n        int j = e[i];\n        if (!color[j]) &#123;\n            if (!DFS(j, 3 - c))\n                return false;\n        &#125; else if (color[j] == c)\n            return false;\n    &#125;\n    return true;\n&#125;\n\nint main()&#123;\n    bool flag = true;\n    for (int i = 1; i &lt;= n; i ++) &#123;\n        if (!color[i]) &#123;\n            if (!DFS(i, 1)) &#123;\n                flag = false;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    if (flag)\n        printf(&quot;Yes&quot;);\n    else\n        printf(&quot;No&quot;);\n&#125;\n</code></pre>\n<h3 id=\"匈牙利算法\"><a href=\"#匈牙利算法\" class=\"headerlink\" title=\"匈牙利算法\"></a>匈牙利算法</h3><p>题型：邻接表，求二分图的最大匹配</p>\n<p>思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配），</p>\n<p>如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] &#x3D; x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。</p>\n<pre><code class=\"c++\">bool find(int x) &#123;\t\t\t//帮助男生 x 匹配女生，成功返回true，否则返回false\n    for (int i = h[x]; i != -1; i = ne[i]) &#123;\n        int j = e[i];\n        if (!st[j]) &#123;\n            st[j] = true;\n            if (match[j] == 0 || find(match[j])) &#123;\n                match[j] = x;\t\t//match[j]代表 女生 j 的匹配的男生为 match[j]\n                return true;\n            &#125;\n        &#125;\n    &#125;\n    return false;\n&#125;\n\nint main()&#123;\n    for (int i = 1; i &lt;= n1; i ++) &#123;\n        memset(st, false, sizeof st);\n        if (find(i))\n            res ++;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"数位Dp\"><a href=\"#数位Dp\" class=\"headerlink\" title=\"数位Dp\"></a>数位Dp</h2><p>把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算</p>\n<pre><code class=\"c++\">int dp(int n)&#123;\n    if (n == 0) return 0;\n\n    vector&lt;int&gt; nums;\n    while(n) nums.push_back(n % B), n /= B;\n\n    int res = 0, last = 0;\n    for (int i = nums.size() - 1; i &gt;= 0; i -- )&#123;\n        int x = nums[i];\n\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h2 id=\"树的最长路径\"><a href=\"#树的最长路径\" class=\"headerlink\" title=\"树的最长路径\"></a>树的最长路径</h2><pre><code class=\"c++\">void dfs(int u, int father)//防止从下往上遍历，引入 father\n&#123;\n    f1[u] = f2[u] = 0;//从 u 点出发， f1 为最长的路径， f2 为第二长的路径\n    for (int i = h[u]; ~i; i = ne[i])\n    &#123;\n        int j = e[i];\n        if (j == father) continue;\n        dfs(j, u);\n        if (f1[j] + w[i] &gt;= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; //最长路转移\n        else if (f1[j] + w[i] &gt; f2[u]) f2[u] = f1[j] + w[i];            //次长路转移\n    &#125;\n    res = max(res, f1[u] + f2[u]);\n&#125;\n</code></pre>\n<h2 id=\"Flood-Fill\"><a href=\"#Flood-Fill\" class=\"headerlink\" title=\"Flood Fill\"></a>Flood Fill</h2><p>求连通块的数量</p>\n<pre><code class=\"c++\">void bfs(int sx, int sy)&#123;\n    st[sx][sy] = true;\n    q[0] = &#123;sx, sy&#125;;\n\n    int hh = 0, tt = 0;\n    while(hh &lt;= tt)&#123;\n        PII t = q[hh ++];\n        for (int i = t.x - 1; i &lt;= t.x + 1; i ++ )\n            for (int j = t.y - 1; j &lt;= t.y + 1; j ++ )&#123;\n                if (i == t.x &amp;&amp; j == t.y) continue;\n                if (g[i][j] == &#39;.&#39; || st[i][j]) continue;\n                if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue;\n                q[ ++ tt] = &#123;i, j&#125;;\n                st[i][j] = true;\n            &#125;\n    &#125;\n&#125;\n\nint cnt = 0;\n    for (int i = 0; i &lt; n; i ++ )\n        for (int j = 0; j &lt; m; j ++ )&#123;\n            if (g[i][j] == &#39;W&#39; &amp;&amp; !st[i][j])&#123; //需要联通的条件，并且该点没有遍历\n                bfs(i, j);\n                cnt ++;\n            &#125;\n        &#125;\n</code></pre>\n<pre><code class=\"c++\">int bfs()&#123;\t//求最短路径\n    memset(dist, -1, sizeof dist);//定义所有点都没有遍历\n    \n    int sx, sy;\n    for (int i = 0; i &lt; n; i ++ )\n        for (int j = 0; j &lt; m; j ++ )\n            if (g[i][j] == &#39;K&#39;)&#123;\n                sx = i, sy = j;\n            &#125;\n    \n    int hh = 0, tt = 0;\n    q[0] = &#123;sx, sy&#125;;\n    dist[sx][sy] = 0;//起始点的距离为0\n    while(hh &lt;= tt)&#123;\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i &lt; 8; i ++ )&#123;\n            int a = t.x + dx[i], b = t.y + dy[i];//枚举下一个点\n            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m) continue;\n            if (g[a][b] == &#39;*&#39;) continue;\n            if (dist[a][b] != -1) continue;//表示下一个点有没有遍历\n            if (g[a][b] == &#39;H&#39;) return dist[t.x][t.y] + 1;\n\n            dist[a][b] = dist[t.x][t.y] + 1;\n            q[ ++ tt] = &#123;a, b&#125;;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"c++\">void bfs(int sx, int sy)&#123;//求最短路径，并且输出路径\n    int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, -1, 0, 1&#125;;\n\n    int hh = 0, tt = 0;\n    q[0] = &#123;sx, sy&#125;;\n\n    memset(pre, -1, sizeof pre);//pre 用于存储路径\n    pre[sx][sy] = &#123;0, 0&#125;;\n//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的\n    while (hh &lt;= tt)&#123;\n        PII t = q[hh ++ ];\n\n        for (int i = 0; i &lt; 4; i ++ )&#123;\n            int a = t.x + dx[i], b = t.y + dy[i];\n            if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue;\n            if (g[a][b]) continue;\n            if (pre[a][b].x != -1) continue;\n\n            q[ ++ tt] = &#123;a, b&#125;;\n            pre[a][b] = t;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h2><h3 id=\"线性筛法求素数\"><a href=\"#线性筛法求素数\" class=\"headerlink\" title=\"线性筛法求素数\"></a>线性筛法求素数</h3><pre><code class=\"c++\">int primes[N], cnt;     // primes[]存储所有素数\nbool st[N];         // st[x]存储x是否被筛掉\n\nvoid get_primes(int n)\n&#123;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (!st[i]) primes[cnt ++ ] = i;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        &#123;\n            st[primes[j] * i] = true;\n            if (i % primes[j] == 0) break;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"欧几里得算法\"><a href=\"#欧几里得算法\" class=\"headerlink\" title=\"欧几里得算法\"></a>欧几里得算法</h3><pre><code class=\"c++\">int gcd(int a, int b)//求最大公约数\n&#123;\n    return b ? gcd(b, a % b) : a;\n&#125;\n</code></pre>\n<h3 id=\"试除法求所有约数\"><a href=\"#试除法求所有约数\" class=\"headerlink\" title=\"试除法求所有约数\"></a>试除法求所有约数</h3><pre><code class=\"c++\">vector&lt;int&gt; get_divisors(int x)\n&#123;\n    vector&lt;int&gt; res;\n    for (int i = 1; i &lt;= x / i; i ++ )\n        if (x % i == 0)\n        &#123;\n            res.push_back(i);\n            if (i != x / i) res.push_back(x / i);//防止相同的数\n        &#125;\n    sort(res.begin(), res.end());\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"筛法求欧拉函数\"><a href=\"#筛法求欧拉函数\" class=\"headerlink\" title=\"筛法求欧拉函数\"></a>筛法求欧拉函数</h3><pre><code class=\"c++\">int primes[N], cnt;     // primes[]存储所有素数\nint euler[N];           // 存储每个数的欧拉函数\nbool st[N];         // st[x]存储x是否被筛掉\n\n\nvoid get_eulers(int n)\n&#123;\n    euler[1] = 1;\n    for (int i = 2; i &lt;= n; i ++ )\n    &#123;\n        if (!st[i])\n        &#123;\n            primes[cnt ++ ] = i;\n            euler[i] = i - 1;\n        &#125;\n        for (int j = 0; primes[j] &lt;= n / i; j ++ )\n        &#123;\n            int t = primes[j] * i;\n            st[t] = true;\n            if (i % primes[j] == 0)\n            &#123;\n                euler[t] = euler[i] * primes[j];\n                break;\n            &#125;\n            euler[t] = euler[i] * (primes[j] - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h3><pre><code class=\"c++\">int qmi(int m, int k, int p)\n&#123;\n    int res = 1 % p, t = m;\n    while (k)\n    &#123;\n        if (k &amp; 1) res = res * t % p;\n        t = t * t % p;\n        k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\n</code></pre>\n<h3 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a>扩展欧几里得算法</h3><pre><code class=\"c++\">// 求x, y，使得ax + by = gcd(a, b)\nint exgcd(int a, int b, int &amp;x, int &amp;y)\n&#123;\n    if (!b)\n    &#123;\n        x = 1; y = 0;\n        return a;\n    &#125;\n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;\n    return d;\n&#125;\n</code></pre>\n","path":"2023/12/16/算法笔记/","permalink":"http://example.com/2023/12/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","tags":[{"name":"算法","_id":"clq83chpb00015ctf9hfvd56l","slug":"算法","path":"tags/算法/","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/","length":1}],"categories":[],"prev":null,"next":{"title":"用ChatGPT做PPT","date":"2023-12-10T04:37:03.000Z","summary":"快速制作一份简单的PPT","slug":"用ChatGPT做PPT","published":true,"updated":"2023-12-14T14:15:18.128Z","_id":"clq5cf05j000fmotfh48o4kvz","layout":"post","photos":[],"link":"","excerpt":"","path":"2023/12/10/用ChatGPT做PPT/","permalink":"http://example.com/2023/12/10/%E7%94%A8ChatGPT%E5%81%9APPT/","__post":true},"__post":true}