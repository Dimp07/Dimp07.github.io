{"pages":[],"posts":[{"title":"Hello World","text":"到此一游","link":"/2023/12/05/Hello/"},{"title":"ChatGPT绘制UML图","text":"工具介绍我们需要的工具是Draw。 Draw是一款免费的流程图制作工具，它提供了丰富的流程图素材，可以轻松地制作出各种复杂的类图。 我们只需要将ChatGPT生成的PlantUML代码复制到Draw的网页版或者本地软件中，Draw就会根据我们输入的代码自动生成一个清晰、美观的类图。 制作步骤接下来，让我们看看具体的制作步骤。 打开ChatGPT的网页版。 在ChatGPT输入类图的步骤和过程，具体可以参照以下prompt： 请作为一个PlantUML类图生成器，待会我会给你提示，你需要根据我的提示内容生成系统UML图，并输出相应的PlantUML代码。 然后指示它开始画： 3.将ChatGPT生成的PlantUML代码复制到Draw的网页版或者本地软件中。在Draw中，选择+号-&gt;高级-&gt;plantuml，然后将代码粘贴到文本框中,点击插入。 我生成的图： （若是报错可以叫ChatGPT用低版本的PlantUML代码） 如果要增加其他需求还可以和ChatGPT说 生成的图不能直接编辑，只能双击修改代码从而影响图 如果对样式不满意，可以再去visio中画一次 有什么需求都可以提，但是要切记字数有限制，尽量加强逻辑缩减你的问题","link":"/2023/12/09/ChatGPT%E7%BB%98%E5%88%B6UML%E5%9B%BE/"},{"title":"MySQL概述","text":"MySQL MySQL命令是用于与MySQL数据库进行交互和操作的命令。这些命令可以用于各种操作，包括连接到数据库、选择数据库、创建表、插入数据、查询数据、删除数据等。 MySQL基础命令 默认端口号：3306 查看服务器版本：select version(); 或者 cmd命令 mysql -verison 登录数据库：mysql -uroot -p 退出数据库：exit/quit 查看当前系统下的数据库：show databases; 创建数据库：create 库名; 使用数据库：use 库名; 查看表：show tables; 建表：create table 表名 (字段名 + 空格 + 数据类型); 查看表结构：desc 表名; 添加值：insert into 表名 (列名) values (值); 查看表中所有数据：select * from 表名; 查询建表时的结构：show create table 表名; 删除字段中的值：delete from 表名 where 条件; 删除表中的字段：delete from 表名 drop column 字段名; 或alter table 表名 drop 字段名 删除表：drop table 表名; 删除库：drop database 库名; 主键约束：primary key 唯一约束：unique 非空约束：not null 默认约束：default 外键约束：foreign key（外键）references主表（主键） 查看别的数据库的表格：show tables from 表名; MySQL命令简介 MySQL命令是用于与MySQL数据库进行交互和操作的命令。 以下是一些常用的MySQL命令： mysql：连接MySQL数据库的命令，需要指定用户名和密码。 use：使用某个数据库。 show databases：显示所有数据库。 create database：创建新的数据库。 drop database：删除数据库。 create table：创建新的表。 alter table：修改表结构。 drop table：删除表。 insert into：向表中插入新的记录。 delete from：删除表中符合条件的记录。 update：更新表中符合条件的记录。 select：查询表中的记录。 where：对查询的记录进行条件筛选。 order by：对查询的记录进行排序。 group by：对查询的记录进行分组。 having：对分组后的记录进行筛选。 set names：设置字符集编码。 这些命令只是MySQL命令的一部分，还有更多的命令可以用于管理和操作MySQL数据库。 MySQL常用命令MySQL准备篇启动和停止MySQL服务12net start mysql // 启动mysql服务net stop mysql // 停止mysql服务 修改MySQL账户密码 修改MySQL的root用户密码，先登陆MySQL 1mysql -u root -p123456 注意：mysql -uroot -p你的MySQL密码 修改root用户的密码： 1ALTER USER 'root'@'localhost' IDENTIFIED BY '新密码'; MySQL的登陆和退出 MySQL登陆 win+R 输入cmd，打开命令行窗口，输入mysql -uroot -p123456 ，回车，出现下图且左下角为mysql&gt; ，则登录成功。 1mysql -uroot -p123456 注意：mysql -uroot -p 你的MySQL密码 MySQL登出 12exitquit 二选一 查看MySQL版本1SELECT VERSION(); DDL篇（数据定义） 在MySQL中，DDL是数据定义语言（Data Definition Language）的缩写，用于定义和管理数据库的结构。 查询数据库 查询所有的数据库 1SHOW DATABASES; 创建数据库 创建数据库： 1CREATE DATABASE 数据库名称; 创建数据库(判断，如果不存在则创建) 1CREATE DATABASE IF NOT EXISTS 数据库名称; 使用数据库 使用数据库 1USE 数据库名称; 查看当前使用的数据库 1SELECT DATABASE(); 删除数据库 删除数据库 1DROP DATABASE 数据库名称; 删除数据库(判断，如果存在则删除) 1DROP DATABASE IF EXISTS 数据库名称; 查询表 查询当前数据库下所有表名称 1SHOW TABLES; 查询表结构 1DESC 表名称; 创建表 创建表 123456CREATE TABLE 表名 (字段名1 数据类型1,字段名2 数据类型2,…字段名n 数据类型n); 12345create table tb_user (id int,username varchar(20),password varchar(32)); 注意：最后一行末尾，不能加逗号 修改表 修改表名 123ALTER TABLE 表名 RENAME TO 新的表名;-- 将表名student修改为stualter table student rename to stu; 添加一列 123ALTER TABLE 表名 ADD 列名 数据类型;-- 给stu表添加一列address，该字段类型是varchar(50)alter table stu add address varchar(50); 修改数据类型 123ALTER TABLE 表名 MODIFY 列名 新数据类型;-- 将stu表中的address字段的类型改为 char(50)alter table stu modify address char(50); 修改列名和数据类型 123ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型;-- 将stu表中的address字段名改为 addr，类型改为varchar(50)alter table stu change address addr varchar(50); 删除列 123ALTER TABLE 表名 DROP 列名;-- 将stu表中的addr字段 删除alter table stu drop addr; 删除表 删除表 1DROP TABLE 表名; 删除表时判断表是否存在 1DROP TABLE IF EXISTS 表名; 查看数据表结构1desc [表名]; 查看建表语句1SHOW CREATE TABLE [表名] 增加、删除和修改字段自增长（1）增加自增长字段 1ALTER TABLE table_name ADD id INT NOT NULL AUTO_INCREMENT PRIMARY KEY; 注意：table_name代表您要增加自增长字段的表名，id代表您要增加的自增长字段名。 （2）修改自增长字段 1ALTER TABLE table_name CHANGE column_name new_column_name INT NOT NULL AUTO_INCREMENT PRIMARY KEY; table_name代表包含自增长字段的表名，column_name代表原始自增长字段名，new_column_name代表新的自增长字段名。请注意，将数据类型更改为INT，否则无法使该列成为自增长主键。完成后，您需要重新启动表格才能使修改生效。 (3）删除自增长字段 1ALTER TABLE table_name MODIFY column_name datatype; 注意：table_name代表要删除自增长字段的表名，column_name代表要删除的自增长字段名，datatype代表要设置的数据类型。 增加、删除和修改数据表的列（1）增加数据表的列 123ALTER TABLE &lt;表名&gt; ADD COLUMN &lt;列名&gt; &lt;数据类型&gt;;ALTER TABLE student ADD COLUMN age INT; 上面的命令会在student表中增加一个名为age的INT类型列。 ​ (2）删除数据表的列 123ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;;ALTER TABLE student DROP COLUMN age; 上面的命令会从student表中删除名为age的列。 (3）修改数据表的列 123ALTER TABLE &lt;表名&gt; MODIFY COLUMN &lt;列名&gt; &lt;数据类型&gt;;ALTER TABLE student MODIFY COLUMN age VARCHAR(10); 上面的命令会将student表中的age列的数据类型修改为VARCHAR(10)。 添加、删除和查看索引（1）添加索引： 要为表中的某个列添加索引，可以使用以下命令： 1ALTER TABLE table_name ADD INDEX index_name (column_name); 其中，table_name是表的名称，index_name是索引的名称，column_name是要添加索引的列的名称。 例如，如果要为名为users的表的email列添加名为idx_email的索引，可以使用以下命令： 1ALTER TABLE users ADD INDEX idx_email (email); (2）删除索引： 要删除表中的索引，可以使用以下命令： 1ALTER TABLE table_name DROP INDEX index_name; 其中，table_name是表的名称，index_name是要删除的索引的名称。 例如，如果要删除名为users的表的idx_email索引，可以使用以下命令： 1ALTER TABLE users DROP INDEX idx_email; （3）查看索引： 要查看表中的索引信息，可以使用以下命令： 1SHOW INDEX FROM table_name; 其中，table_name是表的名称。该命令将返回包含索引信息的结果集。 例如，如果要查看名为users的表的索引信息，可以使用以下命令： 1SHOW INDEX FROM users; 创建临时表 要创建临时表，可以使用以下语法： 12345CREATE TEMPORARY TABLE temp_table_name ( column1 datatype, column2 datatype, ... ); 其中，temp_table_name是您要创建的临时表的名称。您可以指定表的列和数据类型，就像创建常规表一样。 以下是一个具体的例子： 12345CREATE TEMPORARY TABLE temp_users ( id INT PRIMARY KEY, name VARCHAR(50), email VARCHAR(100) ); 上述命令将创建一个名为temp_users的临时表，其中包含id、name和email列。id列是主键。 注意：临时表仅在当前会话可见，并且在会话结束时自动删除。因此，它是一种在会话过程中存储临时数据的便捷方式。 创建内存表 要创建内存表，可以使用以下语法： 12345CREATE TABLE mem_table_name ( column1 datatype, column2 datatype, ... ) ENGINE=MEMORY; 其中，mem_table_name是您要创建的内存表的名称。您可以指定表的列和数据类型，就像创建常规表一样。通过将ENGINE选项设置为MEMORY，该表将被创建为内存表。 以下是一个具体的例子： 12345CREATE TABLE mem_users ( id INT PRIMARY KEY, name VARCHAR(50), email VARCHAR(100) ) ENGINE=MEMORY; 上述命令将创建一个名为mem_users的内存表，其中包含id、name和email列。id列是主键。 注意：内存表存储在内存中，因此数据的修改会立即生效，并且对所有用户可见。但是，当MySQL服务器关闭时，内存表中的数据将丢失。因此，它适用于临时存储数据或缓存等场景。 查看数据库数据表存储位置要查看MySQL数据库中数据表的存储位置，您可以执行以下步骤： 连接到MySQL服务器，可以使用以下命令： 1mysql -u username -p 其中，username是您的MySQL用户名。系统将提示您输入密码。 选择要查看存储位置的数据库。使用以下命令选择数据库： 1USE database_name; 其中，database_name是您要查看存储位置的数据库的名称。 执行以下命令来查看数据表的存储位置： 1SHOW TABLE STATUS; 该命令将返回包含有关数据库中所有数据表的信息的结果集。其中，可以关注File列，它将显示数据表的存储位置。 如果只想查看特定数据表的存储位置，可以结合使用SHOW TABLE STATUS和LIKE语句。例如，要查看名为table_name的表的存储位置，可以执行以下命令： 1SHOW TABLE STATUS LIKE 'table_name'; 这将返回特定数据表的详细信息，包括存储位置。 注意：这些命令在MySQL版本5.5及更高版本中有效。 清空表内容 要清空MySQL表的内容，可以使用以下命令： 1TRUNCATE TABLE table_name; 其中，table_name是要清空内容的表的名称。 该命令将删除表中的所有数据，但保留表的结构。换句话说，它将删除表中的所有行，但保留表的主键、索引和其他属性。 注意：该操作一旦执行，无法恢复表的内容。因此，在使用该命令之前，请确保您已经备份了重要的数据。 DML篇（数据操作） DML是数据操纵语言。它是一组用于管理和处理数据库的命令和语句，用于插入、更新、删除、查询和修改数据库中的数据。 MySQL命令中关于DML的操作主要有增加（Insert）、删除（Delete）和修改（Update） 数据增加 增加操作： 12INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); 例如，要在名为users的表中添加一条记录，可以执行以下命令： 12INSERT INTO users (id, name, email) VALUES (1, 'John Doe', 'john@example.com'); 数据删除 删除操作： 1DELETE FROM table_name WHERE condition; 例如，要删除名为users表中id为1的记录，可以执行以下命令： 1DELETE FROM users WHERE id = 1; 数据修改 修改操作： 1UPDATE table_name SET column1 = value1, column2 = value2 WHERE condition; 例如，要修改名为users表中name为’John Doe’的记录的email，可以执行以下命令： 1UPDATE users SET email = 'newemail@example.com' WHERE name = 'John Doe'; DQL篇（数据查询） MySQL中DQL（Data Query Language）操作的主要命令是SELECT，用于从数据库表中检索数据。 检索所有数据1SELECT * FROM table_name; 这个命令将返回表中的所有记录。 指定要检索的列1SELECT column1, column2 FROM table_name; 这个命令将返回指定的列，例如column1和column2。 使用WHERE子句来指定条件1SELECT * FROM table_name WHERE condition; 这个命令将返回满足指定条件的所有记录。例如，SELECT * FROM users WHERE age &gt; 18 将返回年龄大于 18 的所有用户记录。 使用聚合函数来计算统计数据1SELECT COUNT(*) FROM table_name; 这个命令将返回表中的记录数。还可以使用其他聚合函数，如SUM、AVG、MAX和MIN等。 使用GROUP BY来分组数据1SELECT column1, COUNT(*) FROM table_name GROUP BY column1; 这个命令将按column1分组，并计算每个组中的记录数。 使用ORDER BY来排序数据1SELECT * FROM table_name ORDER BY column1; 这个命令将按column1的升序排序所有记录。还可以使用DESC关键字来按降序排序。#### 4.4.7 使用LIMIT来限制返回的记录数 1SELECT * FROM table_name LIMIT 10; 这个命令将返回表中的前10条记录。还可以使用OFFSET关键字来指定从哪一行开始返回记录。 DCL篇（数据控制） MySQL中DCL（Data Control Language）操作的主要命令是用于管理用户和权限的。 GRANT命令：授予访问权限1GRANT 权限列表 ON 对象类型 对象名称 TO 用户名@用户地址 IDENTIFIED BY用户口令; 例如，给用户test授予对所有数据库的完全访问权限： 1GRANT ALL PRIVILEGES ON *.* TO 'test'@'localhost' IDENTIFIED BY 'password'; REVOKE命令：撤销访问权限1REVOKE 权限列表 ON 对象类型 对象名称 FROM 用户名@用户地址; 例如，撤销用户test对所有数据库的访问权限： 1REVOKE ALL PRIVILEGES ON *.* FROM 'test'@'localhost'; SET PASSWORD命令：修改用户口令1SET PASSWORD FOR 用户名@用户地址 = SET PASSWORD BY PASSWORD ('新口令'); 例如，将用户test的口令修改为新口令： 1SET PASSWORD FOR 'test'@'localhost'=SET PASSWORD BY PASSWORD ('newpassword'); FLUSH命令：刷新权限1FLUSH PRIVILEGES; 例如，刷新权限使应用立即更改： 1FLUSH PRIVILEGES;","link":"/2023/12/09/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Linux基础命令","text":"Linux基础命令Linux的目录结构 /，根目录是最顶级的目录了 Linux只有一个顶级目录：/ 路径描述的层次关系同样适用/来表示 /home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt ls命令功能：列出文件夹信息 语法：ls [-l -h -a] [参数] 参数：被查看的文件夹，不提供参数，表示查看当前工作目录 -l，以列表形式查看 -h，配合-l，以更加人性化的方式显示文件大小 -a，显示隐藏文件 隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。 默认不显示出来，需要-a选项才可查看到。 pwd命令功能：展示当前工作目录 语法：pwd cd命令功能：切换工作目录 语法：cd [目标目录] 参数：目标目录，要切换去的地方，不提供默认切换到当前登录用户HOME目录 HOME目录每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。 普通用户的HOME目录，默认在：/home/用户名 root用户的HOME目录，在：/root FinalShell登陆终端后，默认的工作目录就是用户的HOME目录 相对路径、绝对路径 相对路径，==非==/开头的称之为相对路径 相对路径表示以当前目录作为起点，去描述路径，如test/a.txt，表示当前工作目录内的test文件夹内的a.txt文件 绝对路径，==以==/开头的称之为绝对路径 绝对路径从根开始描述路径 特殊路径符 .，表示当前，比如./a.txt，表示当前文件夹内的a.txt文件 ..，表示上级目录，比如../表示上级目录，../../表示上级的上级目录 ~，表示用户的HOME目录，比如cd ~，即可切回用户HOME目录 mkdir命令功能：创建文件夹 语法：mkdir [-p] 参数 参数：被创建文件夹的路径 选项：-p，可选，表示创建前置路径 touch命令功能：创建文件 语法：touch 参数 参数：被创建的文件路径 cat命令功能：查看文件内容 语法：cat 参数 参数：被查看的文件路径 more命令功能：查看文件，可以支持翻页查看 语法：more 参数 参数：被查看的文件路径 在查看过程中： 空格键翻页 q退出查看 cp命令功能：复制文件、文件夹 语法：cp [-r] 参数1 参数2 参数1，被复制的 参数2，要复制去的地方 选项：-r，可选，复制文件夹使用 示例： cp a.txt b.txt，复制当前目录下a.txt为b.txt cp a.txt test/，复制当前目录a.txt到test文件夹内 cp -r test test2，复制文件夹test到当前文件夹内为test2存在 mv命令功能：移动文件、文件夹 语法：mv 参数1 参数2 参数1：被移动的 参数2：要移动去的地方，参数2如果不存在，则会进行改名 rm命令功能：删除文件、文件夹 语法：rm [-r -f] 参数...参数 参数：支持多个，每一个表示被删除的，空格进行分隔 选项：-r，删除文件夹使用 选项：-f，强制删除，不会给出确认提示，一般root用户会用到 rm命令很危险，一定要注意，特别是切换到root用户的时候。 which命令功能：查看命令的程序本体文件路径 语法：which 参数 参数：被查看的命令 find命令功能：搜索文件 语法1按文件名搜索：find 路径 -name 参数 路径，搜索的起始路径 参数，搜索的关键字，支持通配符*， 比如：*test表示搜索任意以test结尾的文件 grep命令功能：过滤关键字 语法：grep [-n] 关键字 文件路径 选项-n，可选，表示在结果中显示匹配的行的行号。 参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来 参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口 参数文件路径，可以作为管道符的输入 wc命令功能：统计 语法：wc [-c -m -l -w] 文件路径 选项，-c，统计bytes数量 选项，-m，统计字符数量 选项，-l，统计行数 选项，-w，统计单词数量 参数，文件路径，被统计的文件，可作为内容输入端口 参数文件路径，可作为管道符的输入 管道符|写法：| 功能：将符号左边的结果，作为符号右边的输入 示例： cat a.txt | grep itheima，将cat a.txt的结果，作为grep命令的输入，用来过滤itheima关键字 可以支持嵌套： cat a.txt | grep itheima | grep itcast echo命令功能：输出内容 语法：echo 参数 参数：被输出的内容 `反引号功能：被两个反引号包围的内容，会作为命令执行 示例： echo `pwd`，会输出当前工作目录 tail命令功能：查看文件尾部内容 语法：tail [-f] 参数 参数：被查看的文件 选项：-f，持续跟踪文件修改 head命令功能：查看文件头部内容 语法：head [-n] 参数 参数：被查看的文件 选项：-n，查看的行数 重定向符功能：将符号左边的结果，输出到右边指定的文件中去 &gt;，表示覆盖输出 &gt;&gt;，表示追加输出 vi编辑器命令模式快捷键 底线命令快捷键 命令的选项我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。 比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。 课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。 课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。 查看命令的帮助可以通过：命令 --help查看命令的帮助手册 查看命令的详细手册可以通过：man 命令查看某命令的详细手册 Linux常用操作软件安装 CentOS系统使用： yum [install remove search] [-y] 软件名称 install 安装 remove 卸载 search 搜索 -y，自动确认 Ubuntu系统使用 apt [install remove search] [-y] 软件名称 install 安装 remove 卸载 search 搜索 -y，自动确认 yum 和 apt 均需要root权限 systemctl功能：控制系统服务的启动关闭等 语法：systemctl start | stop | restart | disable | enable | status 服务名 start，启动 stop，停止 status，查看状态 disable，关闭开机自启 enable，开启开机自启 restart，重启 软链接功能：创建文件、文件夹软链接（快捷方式） 语法：ln -s 参数1 参数2 参数1：被链接的 参数2：要链接去的地方（快捷方式的名称和存放位置） 日期语法：date [-d] [+格式化字符串] -d 按照给定的字符串显示日期，一般用于日期计算 格式化字符串：通过特定的字符串标记，来控制显示的日期格式 %Y 年%y 年份后两位数字 (00..99) %m 月份 (01..12) %d 日 (01..31) %H 小时 (00..23) %M 分钟 (00..59) %S 秒 (00..60) %s 自 1970-01-01 00:00:00 UTC 到现在的秒数 示例： 按照2022-01-01的格式显示日期 按照2022-01-01 10:00:00的格式显示日期 -d选项日期计算 支持的时间标记为： 时区修改时区为中国时区 ntp功能：同步时间 安装：yum install -y ntp 启动管理：systemctl start | stop | restart | status | disable | enable ntpd 手动校准时间：ntpdate -u ntp.aliyun.com ip地址格式：a.b.c.d abcd为0~255的数字 特殊IP： 127.0.0.1，表示本机 0.0.0.0 可以表示本机 也可以表示任意IP（看使用场景） 查看ip：ifconfig 主机名功能：Linux系统的名称 查看：hostname 设置：hostnamectl set-hostname 主机名 配置VMware固定IP 修改VMware网络，参阅PPT，图太多 设置Linux内部固定IP 修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33 示例文件内容： 12345678910111213141516171819TYPE=&quot;Ethernet&quot;PROXY_METHOD=&quot;none&quot;BROWSER_ONLY=&quot;no&quot;BOOTPROTO=&quot;static&quot; # 改为static，固定IPDEFROUTE=&quot;yes&quot;IPV4_FAILURE_FATAL=&quot;no&quot;IPV6INIT=&quot;yes&quot;IPV6_AUTOCONF=&quot;yes&quot;IPV6_DEFROUTE=&quot;yes&quot;IPV6_FAILURE_FATAL=&quot;no&quot;IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;NAME=&quot;ens33&quot;UUID=&quot;1b0011cb-0d2e-4eaa-8a11-af7d50ebc876&quot;DEVICE=&quot;ens33&quot;ONBOOT=&quot;yes&quot;IPADDR=&quot;192.168.88.131&quot; # IP地址，自己设置，要匹配网络范围NETMASK=&quot;255.255.255.0&quot; # 子网掩码，固定写法255.255.255.0GATEWAY=&quot;192.168.88.2&quot; # 网关，要和VMware中配置的一致DNS1=&quot;192.168.88.2&quot; # DNS1服务器，和网关一致即可 ps命令功能：查看进程信息 语法：ps -ef，查看全部进程信息，可以搭配grep做过滤：ps -ef | grep xxx kill命令 nmap命令 netstat命令功能：查看端口占用 用法：netstat -anp | grep xxx ping命令测试网络是否联通 语法：ping [-c num] 参数 wget命令 curl命令 top命令功能：查看主机运行状态 语法：top，查看基础信息 可用选项： 交互式模式中，可用快捷键： df命令查看磁盘占用 iostat命令查看CPU、磁盘的相关信息 sar命令查看网络统计 环境变量 临时设置：export 变量名=变量值 永久设置： 针对用户，设置用户HOME目录内：.bashrc文件 针对全局，设置/etc/profile PATH变量记录了执行程序的搜索路径 可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果 $符号可以取出指定的环境变量的值 语法：$变量名 示例： echo $PATH，输出PATH环境变量的值 echo ${PATH}ABC，输出PATH环境变量的值以及ABC 如果变量名和其它内容混淆在一起，可以使用${} 压缩解压压缩tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N -z表示使用gzip，可以不写 zip [-r] 参数1 参数2 参数N 解压tar -zxvf 被解压的文件 -C 要解压去的地方 -z表示使用gzip，可以省略 -C，可以省略，指定要解压去的地方，不写解压到当前目录 unzip [-d] 参数 su命令切换用户 语法：su [-] [用户] sudo命令 比如： 1itheima ALL=(ALL) NOPASSWD: ALL 在visudo内配置如上内容，可以让itheima用户，无需密码直接使用sudo chmod命令修改文件、文件夹权限 语法：chmod [-R] 权限 参数 权限，要设置的权限，比如755，表示：rwxr-xr-x 参数，被修改的文件、文件夹 选项-R，设置文件夹和其内部全部内容一样生效 chown命令修改文件、文件夹所属用户、组 语法：chown [-R] [用户][:][用户组] 文件或文件夹 用户组管理 用户管理 genenv命令 getenv group，查看系统全部的用户组 getenv passwd，查看系统全部的用户 env命令查看系统全部的环境变量 语法：env","link":"/2023/12/09/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"},{"title":"使用Git提交本地文件到Github上","text":"绑定 Git 与 Github 生成SSH key 要想生成SSH key，首先就得安装 SSH，对于Linux 和 Mac 系统，其默认是安装 SSH 的，而对于 Windows 系统，其默认是不安装 SSH 的，不过由于我们安装了 Git Bash，其也应该自带了 SSH. 可以通过在 Git Bash 中输入 ssh 命令，查看本机是否安装 SSH： 如果出现上图所示，则说明已经安装 SSH ，输入 ssh-keygen -t rsa 命令，表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录： Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username\\\\.ssh Windows 10 ThinkPad：C:\\Users\\think\\.ssh 密钥和公钥生成之后，我们要做的事情就是把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码了。 添加 SSH key 进入Github主页，点击头像，点击 Settings。 进入后点击 SSH and GPG keys。 点击 New SSH key。 Title 可以自己定义，Key 处填 id_rsa.pub 里的内容。 验证绑定是否成功 添加完成 SSH key 后可以在 Git Bash 中输入 ssh -T git@github.com 进行判断。 如图所示，即为 Git 与 Github 绑定成功。 将本地文件提交到 Github 上 在 Github 上创建 repository 点击 Your repositories. 之后点击 New 。 输入创建的 Repository name，（记得勾选 Add a README file）。 克隆 Github 上的仓库到本地。 点击 Code ，点击 SSH ， 复制链接。 在 Git Bach 上输入 git clone &quot;复制的链接&quot; 命令。 如下图所示，即为成功。 将本地文件提交到 Github 上。 在 Git Bach 上输入 cd text-01/ 命令（ cd 后面的是你创建的文件夹名字），或者是关掉Git Bach，在 text-01 文件夹中打开 Git Bach 。 输入 git status 命令可以查看仓库状态。 在 text-01中新建一个文件 work.txt，用于提交测试。 输入 git add ./ 命令（add 后面有空格，才到 .），再输入 git commit -m&quot;注释&quot; 命令。 输入 git push origin main 命令，等待完成后在 Github 上刷新页面，就会发现提交成功。 如果在输入 git commit 命令时出现 fatal: unable to auto-detect email address (got ‘…@…(none)’) 。这是由于未配置github用户名和邮箱所致 解决方法：配置 Github 用户名与邮箱。用户名是 Github 上的用户名， 邮箱是注册 Github 时用的邮箱，输入命令时用户名与邮箱要加上 “” 。 git config --global user.name &quot;你的用户名&quot; git config --global user.email &quot;你的邮箱&quot; 以上就是使用 Git 提交本地文件到 Github 上的内容。","link":"/2023/12/05/%E4%BD%BF%E7%94%A8Git%E6%8F%90%E4%BA%A4%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E5%88%B0Github%E4%B8%8A/"},{"title":"如何保存别人的csdn博客到本地","text":"准备工作一篇喜欢的博客 属于自己的csdn账号 浏览器 方法/步骤 首先,在自己喜欢的博客页面,点击鼠标右键,看到如下图片,点击检查(或者是按f12)。 然后,在右边的源码里边,找到”article_content”标签头,可以看到左侧部分的预览界面被选中的部分就是要复制粘贴文章(包括html部分),检查左侧被选中的部分是否是自己想要的部分。 之后,再右键选择该标签(“article_content”),如下图,选择Copy element复制(或者Cut element 剪切)该标签下的所有元素 将markdown模式转化为普通的富文本模式方法： （1）在桌面新建txt格式文本文档，把第3步拷贝的内容粘贴到文本文档里。 （2）把该txt文件后缀名改为html： （3）双击打开，会发现是带格式，带图片的完美文档 （4）在这个页面上Ctrl+A复制全部内容，保存到一个新的md，再进行修改。","link":"/2023/12/09/%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%88%AB%E4%BA%BA%E7%9A%84csdn%E5%8D%9A%E5%AE%A2%E5%88%B0%E6%9C%AC%E5%9C%B0/"},{"title":"如何高效且优雅做笔记？","text":"如何高效且优雅做笔记？你是这样做笔记的吗？对着电脑边看边做笔记，有些时候还找不到笔，做笔记的时候也容易沾上墨水，甚至连个圆也画不好。 那么我们该如何高效且优雅做笔记呢？ 需要的工具电脑一台、数位板、Onenote、Typora。 电脑不用多说，我们先来讲讲数位板。 什么是数位板？数位板，又名绘图板、绘画板、手绘板等等，是计算机输入设备的一种，通常是由一块板子和一支压感笔组成，它和手写板等作为非常规的输入产品相类似，都针对一定的使用群体。用作绘画创作方面，就像画家的画板和画笔，我们在动画电影中常见的逼真的画面和栩栩如生的人物，就是通过数位板一笔一笔画出来的。数位板的这项绘画功能，是键盘和手写板无法媲美之处。数位板主要面向设计、美术相关专业师生、广告公司与设计工作室以及Flash矢量动画制作者。（调用百度百科） 我们该用什么样的数位板？仅对于做笔记而言，价位为百元左右的数位板完全可以胜任。在这里推荐高漫1060pro。 至于使用规格、产品参数什么的不需要多言，因为我们只是用来做笔记，没有专业性的要求。 OnenoteOneNote是你电脑的Windows系统自带的软件，也是office软件全家桶里不起眼的小透明。 给个使用指南的链接OneNote使用指南 - 知乎 (zhihu.com) 在这里只简述重要的功能： 轻轻松松写数学公式 OneNote里，你可以点击“插入”，选择手写公式或者键入公式，你想要的符号一应俱全！ 不仅可以记笔记，还可以记录音频 当你插入你的课本图片，想要专门听某一道题的时候，跟着我的步骤来： 插入需要的音频 在旁边的空白处点取插入文本，输入播放的时长即可。 旁边会有一个播放键，为了给大家理解的时间，还特别贴心的会有几秒的延迟哦 也可以用作草稿纸使用 完全当成草稿纸，而且不怕数据丢失。（请忽视字丑。。） 画图与打字兼而有之 可以高效作图，并且可以在旁边打字，避免字太丑而看不懂。 Typora说完了Onenote，来说说Typora，这同样是一款功能强大的软件。我现在写的博客或者是文案作业都是使用它来完成。 什么是Typora？ Typora是一款免费的轻量级Markdown编辑器，它没有Mou，Haroopad等Markdown编辑器那么大名鼎鼎，算是较为小众的一款产品。凭良心说话，我用过的Markdown编辑器也有好几款，其中包括：小书匠，Haroopad，Atom等，但Typora是最合我心意的一款编辑器了。 具体介绍移步到Typora - 不要太棒的Markdown编辑器 - 知乎 (zhihu.com) 使用效果以我自身为例，我的专业为软件工程，平常需要敲许多代码，而代码也不是随便敲出来的，所以需要用到草稿纸，前面介绍的数位板+Onenote就可以很好解决这个问题，跟以前高中做数学题一样。 而这个仅仅只是做草稿，如果追求笔记的效果那就画图好些，然后将图片加载到Typora上，保存数据，做到真正意义上的做笔记！ 不仅如此，对于经常需要敲代码的我而言，能够将代码也写入到笔记中是一件多么美妙的事情！ 目前所展现出的仅仅是冰山一角，还有许多功能还没有被开发出来，我也十分期待后续他带给我的惊喜。","link":"/2023/12/09/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E4%B8%94%E4%BC%98%E9%9B%85%E5%81%9A%E7%AC%94%E8%AE%B0%EF%BC%9F/"},{"title":"用ChatGPT做PPT","text":"制作一份简单的PPT需要几步？ 三步 接下来，我们借助ChatGPT和MindShow，大概三分钟完成操作，就能制作出来完胜大部分人的PPT文件。具体可看文末效果导示。 第一步：获取PPT内容大概 进入chatgpt的官网：OpenAI 向他提问，提问格式如下，主题替换成你想获得的信息。比如某本书的拆解，自媒体运营技巧等等 整理一份PPT提纲，主题是… 或者是将大致的内容输入给ChatGPT，让他生成一份MarkDown格式。 注意：告诉chatgpt使用markdown代码呈现，如下。 点击右侧的copy code，借后续步骤使用 第二步：转换成PPT内容 进入MindShow官网：MindShow | AI生成PPT，快速演示你的想法 点击“我的文档”，然后导入 在右侧选择Markdown类型，粘贴第一步获得的内容 导入创建 第三步：修改和下载 进入修改页面，左侧可以修改展示的文字内容 右侧上半部是预览窗口 右侧可以修改模版和布局 点击右侧顶部下载，就可以获得一份高质量PPT了","link":"/2023/12/10/%E7%94%A8ChatGPT%E5%81%9APPT/"},{"title":"算法笔记","text":"C++头文件12345678910111213#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PIIvector&lt;int&gt; alls; string 的函数12345int main(){ string a; a.substr(0, k) //从 a[0] 开始到 a[k] ，返回这段字符串 a.substr(1) //从 a[1] 开始到末尾，返回这段字符串} 排列组合 123456789101112131415161718192021222324252627//从m个数里抽出n个数，进行全排列int arrange(int m,int n){ if(m==n)return n; return m*arrange(m-1,n);}//从m个数里抽出n个数，进行组合排序//法一int cnm(int n,int m){ if(n==1)return m; return m*cnm(n-1,m-1)/n;}//法二int cnm(int n,int m){ if(n==1)return m; if(n==m)return 1; return (cnm(n,m-1)+cnm(n-1,m-1));}//法三 从 i 个数里抽出 j 个数的方案数void init(){ for (int i = 0; i &lt; N; i ++ ) for (int j = 0; j &lt;= i; j ++ ){ if (!j) f[i][j] = 1; else f[i][j] = f[i - 1][j] + f[i - 1][j - 1]; }} 二位前缀和 差分在数组a[l,r]区间内加上c，则可表示为a[l]+=c,a[r+1]+=-c 位运算x&gt;&gt;1，代表x右移一位，值变成1/2；x&lt;&lt;1，代表x左移一位，值变成2倍。二进制的位数n为该数的2^n。 x &gt;&gt; k &amp; 1 , 代表 x 的第 k 位是否为 1. 123int lowbit(int x){ //返回最后一个1的位数 return x&amp;-x; /*例如 10 的二进制为 1010，则返回 10*/} 离散化123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; alls;//储存所有待离散化的值sort(alls.begin(),alls.end());//将所有的值排序alls.erase(unique(alls.begin(),alls,end),alls.end);//去掉重复元素//二分法求出x对应的离散化的值int find(int x){ int l = 0, r = alls.size() - 1; while(l &lt; r){ int mid = l + r; if(alls[mid] &gt;= x){ r = mid; } else{ l = mid +1; } } return r + 1;//返回 1，2，3，4……} KMP12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 10010; //N为模式串长度，M匹配串长度int n, m;int ne[M]; //next[]数组，避免和头文件next冲突char s[N], p[M]; //s为模式串， p为匹配串int main(){ cin &gt;&gt; n &gt;&gt; s+1 &gt;&gt; m &gt;&gt; p+1; //下标从1开始 //求next[]数组 for(int i = 2, j = 0; i &lt;= m; i++) { while(j &amp;&amp; p[i] != p[j+1]) j = ne[j]; if(p[i] == p[j+1]) j++; ne[i] = j; } //匹配操作 for(int i = 1, j = 0; i &lt;= n; i++) { while(j &amp;&amp; s[i] != p[j+1]) j = ne[j]; if(s[i] == p[j+1]) j++; if(j == m) //满足匹配条件，打印开头下标, 从0开始 { //匹配完成后的具体操作 //如：输出以0开始的匹配子串的首字母下标 //printf(&quot;%d &quot;, i - m); (若从1开始，加1) j = ne[j]; //再次继续匹配 } } return 0;} Trie树 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx = 0;void insert(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (son[p][u] == 0) son[p][u] = ++idx; p = son[p][u]; } cnt[p]++;}int query(char str[]) { int p = 0; for (int i = 0; str[i]; i++) { int u = str[i] - 'a'; if (son[p][u] == 0) return 0; p = son[p][u]; } return cnt[p];} 并查集12345678910111213141516int find(int x)//返回x的祖宗节点，并压缩路径{ if(p[x] != x)p[x] = find(p[x]); return p[x];}// 连接a,b两个节点，则为 p[find(a)] = find(b),意味着a的祖宗节点连接到b的祖宗节点上（a的祖宗认了个爹），则 size[find(b)] += size[find(a)]//如果要合并两个节点，则void merge(int a,int b){ //if(find(a) == find(b)) continue; //两个节点已经在同一个集合，无需操作，直接下一步 size[find(b)] += size[find(a)]; //必须先加size，再合并（a,b） p[find(a)] = find(b); //加size时两个还未合并，因此代表的是各集合的数量，这样加才有意义 //如果先合并再相加，则代表两个相同的集合数量相加} 哈希表1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//开放寻址法一般开 数据范围的 2~3倍, 这样大概率就没有冲突了const int N = 2e5 + 3; //大于数据范围的第一个质数const int null = 0x3f3f3f3f; //规定空指针为 null 0x3f3f3f3fint h[N];int find(int x) { int t = (x % N + N) % N; while (h[t] != null &amp;&amp; h[t] != x) { t++; if (t == N) { t = 0; } } return t; //如果这个位置是空的, 则返回的是他应该存储的位置}int main() { int n; scanf(&quot;%d&quot;, &amp;n); memset(h, null, sizeof(h)); while (n --) { char op[2]; int x; scanf(&quot;%s%d&quot;, op, &amp;x); if (op[0] == 'I') { h[find(x)] = x; } else { if (h[find(x)] == null) { printf(&quot;No&quot;); } else { printf(&quot;Yes&quot;); } printf(&quot;\\n&quot;); } } return 0;} 字符串哈希表 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;int const N = 10000010, P = 131; //P = 131 或者是 13331 Q一般取 2^64// P 代表进制 ULL h[N], p[N];char a[N];ULL query(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1];}int main() { int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); scanf(&quot;%s&quot;, a + 1); h[0] = 0, p[0] = 1; for (int i = 1; i &lt;= n; i ++) { h[i] = h[i - 1] * P + a[i]; p[i] = p[i - 1] * P; } while (m --) { int l1, l2, r1, r2; scanf(&quot;%d %d %d %d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2); if (query(l1, r1) == query(l2, r2)) printf(&quot;Yes\\n&quot;); else printf(&quot;No\\n&quot;); } return 0;} 最小根堆1234567#include &lt;iostream&gt;#include &lt;queue&gt;#icnlude &lt;vector&gt;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; heap;heap.push(x), x = heap.top(), heap.pop();//每次弹出来的顶端都是最小值，并且push后堆会自动排序 关于sort()函数123456int num[100];bool cmp(int a,int b){ return a &gt; b; //a&gt;b为由大到小，b&lt;a为由小到大}sort(num,num+100,cmp); 123456789struct Edge{ int a, b , w;}edges[N];bool cmp(Edge a, Edge b){ //按照w的大小排序，此时为递增 return a.w &lt; b.w;}sort(edges, edges + m, cmp); 1234//可以自定义排序bool cmp(int x,int y){ //按照个位数的大小排序，此时为递增 return x % 10 &lt; y % 10;} sort(首地址，尾地址+1，cmp) 这个函数可以传两个或者三个参数 第一个参数是要排序的区间首地址 第二个参数是区间尾地址的下一个地址 第三个参数不写,则为递增排序 求最大公约数、最小公倍数1234567int gcd(int a, int b){ //最大公约数 return b ? gcd(b, a % b) : a;}int gcb(int a, int b){ //最小公倍数 return a * b / gcd(a, b);} 取模同余定理：x%mod=(x+mod)%mod 无穷大inf = 0x3f3f3f3f 二分 归并排序123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 5;int a[N], tmp[N];void merge_sort(int l, int r){ if(l &gt;= r) return ; int mid = l + r &gt;&gt; 1; merge_sort(l, mid), merge_sort(mid + 1, r); int k = 0, i = l, j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= r){ if(a[i] &lt;= a[j]) tmp[k ++] = a[i ++]; else tmp[k ++] = a[j ++]; } while(i &lt;= mid) tmp[k ++] = a[i ++]; while(j &lt;= r) tmp[k ++] = a[j ++]; for (int i = l, j = 0; i &lt;= r; i ++, j ++) a[i] = tmp[j];} 图论初始化 123456789101112int e[N], ne[N], h[N], w[N], dist[N], idx;int n, m;bool st[N];void add(int a, int b, int c) { e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++;}int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); memset(h, -1, sizeof h);} Dijkstra算法朴素版 题型：稠密图 思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边 12345678910111213141516171819int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; for(int i = 1; i &lt;= n; i++) { int t = -1; for(int j = 1; j &lt;= n; j++) { if(!visited[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } visited[t] = true; for(int j = 1; j &lt;= n; j++) dist[j] = min(dist[j], dist[t] + g[t][j]); } if(dist[n] == 0x3f3f3f3f) return -1; return dist[n];} 堆优化 题型：稀疏图 思想：每次确定不在集合 st 中距离最小的点，并用该点来更新其他边 12345678910111213141516171819202122232425262728293031int dijkstra(){ memset(dist, 0x3f, sizeof(dist)); dist[1] = 0; priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; // 定义一个小根堆 // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离， // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。 heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second， // 这里显然要根据距离排序 while(heap.size()) { PII k = heap.top(); // 取不在集合S中距离最短的点 heap.pop(); int ver = k.second, distance = k.first; if(st[ver]) continue; st[ver] = true; for(int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。 if(dist[j] &gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({ dist[j], j }); } } } if(dist[n] == 0x3f3f3f3f) return -1; else return dist[n];} Spfa算法可用于负权图 1dist[j] = dist[t] + w[i] //当dist[t]变小时才需要更新，因此每当dist[t]变小时就将 t 加入到队列中，再更新 t 的边 12345678910111213141516171819202122232425int spfa(){ queue&lt;PII&gt; q; memset(dist,0x3f,sizeof dist); dist[1]=0; q.push({0,1}); st[1]=true; while(q.size()){ PII p=q.front(); q.pop(); int t=p.se; st[t]=false;//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队 for(int i=h[t];i!=-1;i=ne[i]){ int j=e[i]; if(dist[j]&gt;dist[t]+w[i]){ dist[j]=dist[t]+w[i]; if(!st[j]){//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率 st[j]=true; q.push({dist[j],j}); } } } } if(dist[n]==0x3f3f3f3f) return -1; else return dist[n];} 如果是判断有无负权回路，则维护 cnt[]，记录 能到达每个点的边数， 如果边数大于 n ，则图中有负权回路。 123456789101112131415161718192021222324252627282930bool spfa() { queue&lt;int&gt; q; for (int i = 1; i &lt;= n; i ++) {//需要判断的是有无负权回路，则应该是从每个点开始遍历 q.push(i); st[i] = true; } while (q.size()) { int t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] &gt; n) return true; if (!st[j]) { st[j] = true; q.push(j); } } } } return false;} 12345678910111213141516171819202122232425262728void spfa() { //从 start 到 ed 的最小权重 memset(dist, 0x3f, sizeof dist); dist[start] = 0; q[0] = start, st[start] = true; int hh = 0, tt = 1; while (hh != tt) { int t = q[hh ++]; if (hh == N) hh = 0; st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] &gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) { q[tt ++] = j; if (tt == N) tt = 0; st[j] = true; } } } }} Bellman_ford算法可用于负权回路图。 1—n 应该有n - 1条边，但如果迭代了n次，就意味着图中肯定有回路 核心思想：for循环 k 次，如果dist[n] 为 0x3f3f3f3f / 2 ，即无法用 k 步走到 n 点 123456789101112131415int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i &lt; k; i++) {//k次循环 memcpy(back, dist, sizeof dist); for (int j = 0; j &lt; m; j++) {//遍历所有边 int a = e[j].a, b = e[j].b, w = e[j].w; dist[b] = min(dist[b], back[a] + w); //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来 } } if (dist[n] &gt; 0x3f3f3f3f / 2) return -1; else return dist[n];} Prim算法题型：稠密图，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小） 思想：从 n 个点中选出一个离当前生成树的最小路径，res +=该路径，并且用这个点更新其余的点（ dist[ j ] = min(dist[ j ], g[ t ][ j ])；如果该点是孤立点，则 dist[ j ] = INF（该点到当前生成树的距离为INF，即没有相通，为孤立点）。 123456789101112131415161718192021222324int Prim() { memset(dist, 0x3f, sizeof dist); //dist[j]： 点j到目前生成树的距离 int res = 0; for (int i = 0; i &lt; n; i ++) { int t = -1; for (int j = 1; j &lt;= n; j ++) { if (!st[j] &amp;&amp; (t == -1 || dist[j] &lt; dist[t])) t = j; } if (i) res += dist[t]; for (int j = 1; j &lt;= n; j ++) { dist[j] = min(dist[j], g[t][j]); } if (i &amp;&amp; dist[t] == INF) return INF; st[t] = true; } return res;} Kruskal算法题型：稀疏图，求最小的生成树（用 n - 1 条边连接 n 个点，并且权值总和最小） 思想：将所有的边权值从小到大排序，在从头开始遍历。如果该边的两个点不在同一个集合中，则把两个点连到同一个图中（并查集的连通操作），并且 res += 边权值，cnt ++。 1234567891011121314151617181920int main(){sort(edges, edges + m, cmp); int res = 0, cnt = 0; for (int i = 0; i &lt; m; i ++) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) { res += w; cnt ++; p[a] = b; } } if (cnt &lt; n - 1)//边数小于 n - 1 说明有孤立点 printf(&quot;impossible&quot;); else printf(&quot;%d&quot;, res);} 染色法判定二分图题型：判断二分图 思想：使用 DFS ，用 1 ， 2 染色，如果相邻的点颜色相同，则不是二分图 1234567891011121314151617181920212223242526272829bool DFS(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!color[j]) { if (!DFS(j, 3 - c)) return false; } else if (color[j] == c) return false; } return true;}int main(){ bool flag = true; for (int i = 1; i &lt;= n; i ++) { if (!color[i]) { if (!DFS(i, 1)) { flag = false; break; } } } if (flag) printf(&quot;Yes&quot;); else printf(&quot;No&quot;);} 匈牙利算法题型：邻接表，求二分图的最大匹配 思想：n1 个点代表 n1 个男生， n2 个点代表 n2 个女生，要求匹配的男女生数最大（最大匹配）， 如果一个男生 x 匹配好了一个女生 j ，则 match[ j ] = x ,如果后面的男生要想匹配这个女生，则先观察 男生 x 能否匹配另外一个女生，即 find(match[ j ])。 123456789101112131415161718192021bool find(int x) { //帮助男生 x 匹配女生，成功返回true，否则返回false for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; //match[j]代表 女生 j 的匹配的男生为 match[j] return true; } } } return false;}int main(){ for (int i = 1; i &lt;= n1; i ++) { memset(st, false, sizeof st); if (find(i)) res ++; }} 数位Dp把数拆开来看，如 13 的二进制为 1101 ，通过判断这四位数字来计算 12345678910111213int dp(int n){ if (n == 0) return 0; vector&lt;int&gt; nums; while(n) nums.push_back(n % B), n /= B; int res = 0, last = 0; for (int i = nums.size() - 1; i &gt;= 0; i -- ){ int x = nums[i]; } return res;} 树的最长路径12345678910111213void dfs(int u, int father)//防止从下往上遍历，引入 father{ f1[u] = f2[u] = 0;//从 u 点出发， f1 为最长的路径， f2 为第二长的路径 for (int i = h[u]; ~i; i = ne[i]) { int j = e[i]; if (j == father) continue; dfs(j, u); if (f1[j] + w[i] &gt;= f1[u]) f2[u] = f1[u] ,f1[u] = f1[j] + w[i]; //最长路转移 else if (f1[j] + w[i] &gt; f2[u]) f2[u] = f1[j] + w[i]; //次长路转移 } res = max(res, f1[u] + f2[u]);} Flood Fill求连通块的数量 1234567891011121314151617181920212223242526void bfs(int sx, int sy){ st[sx][sy] = true; q[0] = {sx, sy}; int hh = 0, tt = 0; while(hh &lt;= tt){ PII t = q[hh ++]; for (int i = t.x - 1; i &lt;= t.x + 1; i ++ ) for (int j = t.y - 1; j &lt;= t.y + 1; j ++ ){ if (i == t.x &amp;&amp; j == t.y) continue; if (g[i][j] == '.' || st[i][j]) continue; if (i &lt; 0 || i &gt;= n || j &lt; 0 || j &gt;= m) continue; q[ ++ tt] = {i, j}; st[i][j] = true; } }}int cnt = 0; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ){ if (g[i][j] == 'W' &amp;&amp; !st[i][j]){ //需要联通的条件，并且该点没有遍历 bfs(i, j); cnt ++; } } 12345678910111213141516171819202122232425262728int bfs(){ //求最短路径 memset(dist, -1, sizeof dist);//定义所有点都没有遍历 int sx, sy; for (int i = 0; i &lt; n; i ++ ) for (int j = 0; j &lt; m; j ++ ) if (g[i][j] == 'K'){ sx = i, sy = j; } int hh = 0, tt = 0; q[0] = {sx, sy}; dist[sx][sy] = 0;//起始点的距离为0 while(hh &lt;= tt){ PII t = q[hh ++ ]; for (int i = 0; i &lt; 8; i ++ ){ int a = t.x + dx[i], b = t.y + dy[i];//枚举下一个点 if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= m) continue; if (g[a][b] == '*') continue; if (dist[a][b] != -1) continue;//表示下一个点有没有遍历 if (g[a][b] == 'H') return dist[t.x][t.y] + 1; dist[a][b] = dist[t.x][t.y] + 1; q[ ++ tt] = {a, b}; } }} 1234567891011121314151617181920212223void bfs(int sx, int sy){//求最短路径，并且输出路径 int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1}; int hh = 0, tt = 0; q[0] = {sx, sy}; memset(pre, -1, sizeof pre);//pre 用于存储路径 pre[sx][sy] = {0, 0};//一般从终点状态开始， 遍历到起始状态，因为 pre 是倒着存储的 while (hh &lt;= tt){ PII t = q[hh ++ ]; for (int i = 0; i &lt; 4; i ++ ){ int a = t.x + dx[i], b = t.y + dy[i]; if (a &lt; 0 || a &gt;= n || b &lt; 0 || b &gt;= n) continue; if (g[a][b]) continue; if (pre[a][b].x != -1) continue; q[ ++ tt] = {a, b}; pre[a][b] = t; } }} 数学知识线性筛法求素数123456789101112131415int primes[N], cnt; // primes[]存储所有素数bool st[N]; // st[x]存储x是否被筛掉void get_primes(int n){ for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] &lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } }} 欧几里得算法1234int gcd(int a, int b)//求最大公约数{ return b ? gcd(b, a % b) : a;} 试除法求所有约数123456789101112vector&lt;int&gt; get_divisors(int x){ vector&lt;int&gt; res; for (int i = 1; i &lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i);//防止相同的数 } sort(res.begin(), res.end()); return res;} 筛法求欧拉函数12345678910111213141516171819202122232425262728int primes[N], cnt; // primes[]存储所有素数int euler[N]; // 存储每个数的欧拉函数bool st[N]; // st[x]存储x是否被筛掉void get_eulers(int n){ euler[1] = 1; for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] &lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } }} 快速幂1234567891011int qmi(int m, int k, int p){ int res = 1 % p, t = m; while (k) { if (k &amp; 1) res = res * t % p; t = t * t % p; k &gt;&gt;= 1; } return res;} 扩展欧几里得算法123456789101112// 求x, y，使得ax + by = gcd(a, b)int exgcd(int a, int b, int &amp;x, int &amp;y){ if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d;}","link":"/2023/12/16/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ChatGPT","slug":"ChatGPT","link":"/tags/ChatGPT/"},{"name":"常用命令","slug":"常用命令","link":"/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"技术向","slug":"技术向","link":"/tags/%E6%8A%80%E6%9C%AF%E5%90%91/"},{"name":"记笔记","slug":"记笔记","link":"/tags/%E8%AE%B0%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[]}